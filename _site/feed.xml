<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xiaoh&#39;s Blog</title>
    <description>死生切阔，与子成说，执子之手，与子偕老。| 这里是 Xiaoh 的个人博客 | 外接各种互联网项目</description>
    <link>http://www.xiaoh.me/</link>
    <atom:link href="http://www.xiaoh.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 14 Feb 2018 08:59:07 +0800</pubDate>
    <lastBuildDate>Wed, 14 Feb 2018 08:59:07 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>NSQ消息队列详解</title>
        <description>&lt;h1 id=&quot;nsq-&quot;&gt;NSQ-异步消息队列&lt;/h1&gt;

&lt;p&gt;NSQ是Golang编写的分布式实时消息平台&lt;br /&gt;
+ Github地址：https://github.com/nsqio/nsq&lt;br /&gt;
+ NSQ官网的文档：http://nsq.io/overview/quick_start.html&lt;/p&gt;

&lt;h3 id=&quot;nsq&quot;&gt;NSQ简介&lt;/h3&gt;

&lt;p&gt;NSQ可用于大规模系统中的实时消息服务，并且每天能够处理数亿级别的消息，其设计目标是为在分布式环境下运行的去中心化服务提供一个强大的基础架构。&lt;/p&gt;

&lt;p&gt;NSQ具有分布式、去中心化的拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。NSQ非常容易配置和部署，且具有最大的灵活性，支持众多消息协议。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;nsq-1&quot;&gt;NSQ组件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;nsqd 守护进程；接收，接收，缓存，投递消息给客户端
    &lt;ul&gt;
      &lt;li&gt;它可以独立运行，不过通常它是由 nsqlookupd 实例所在集群配置的（它在这能声明 topics 和 channels，以便大家能找到）&lt;/li&gt;
      &lt;li&gt;服务启动后有两个端口：一个给客户端，另一个是 HTTP API。还能够开启HTTPS。&lt;/li&gt;
      &lt;li&gt;同一台服务器启动多个nsqd，要注意端口和数据路径必须不同，包括：–lookupd-tcp-address、 -tcp-address、–data-path。&lt;/li&gt;
      &lt;li&gt;删除topic、channel需要http api调用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;nsqlookupd 守护进程；负责管理拓扑信息并提供最终一致性的发现服务
    &lt;ul&gt;
      &lt;li&gt;客户端通过查询 nsqlookupd 来发现指定话题（topic）的生产者，并且 nsqd 节点广播话题（topic）和通道（channel）信息&lt;/li&gt;
      &lt;li&gt;该服务运行后有两个端口：TCP 接口，nsqd 用它来广播；HTTP 接口，客户端用它来发现和管理。&lt;/li&gt;
      &lt;li&gt;在生产环境中，为了高可用，最好部署三个nsqlookupd服务。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;nsqadmin（提供 Web 页面用来实时的管理你的 NSQ 集群。它通过和 nsqlookupd 实例交流，来确定生产者）
    &lt;ul&gt;
      &lt;li&gt;nsqadmin 是一套 WEB UI，用来汇集集群的实时统计，并执行不同的管理任务。&lt;/li&gt;
      &lt;li&gt;运行后，能够通过4171端口查看并管理topic和channel。&lt;/li&gt;
      &lt;li&gt;通常只需要运行一个。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;nsq-2&quot;&gt;NSQ工具&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;nsq_pubsub&lt;/li&gt;
  &lt;li&gt;nsq_stat&lt;/li&gt;
  &lt;li&gt;nsq_tail&lt;/li&gt;
  &lt;li&gt;nsq_to_file&lt;/li&gt;
  &lt;li&gt;nsq_to_http&lt;/li&gt;
  &lt;li&gt;nsq_to_nsq&lt;/li&gt;
  &lt;li&gt;to_nsq&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;nsq-3&quot;&gt;NSQ核心概念&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;topic: topic是nsq的消息发布的逻辑关键词。当程序初次发布带topic的消息时,如果topic不存在,则会被创建。&lt;/li&gt;
  &lt;li&gt;channels: 当生产者每次发布消息的时候,消息会采用多播的方式被拷贝到各个channel中,channel起到队列的作用。&lt;/li&gt;
  &lt;li&gt;messages: 数据流的形式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://f.cloud.github.com/assets/187441/1700696/f1434dc8-6029-11e3-8a66-18ca4ea10aca.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图表明：&lt;br /&gt;
+ 没有router&lt;br /&gt;
    + 对于消息中间件，话题（topic）和通道（channel）是非常基本的，他们是1:N 的关系。&lt;br /&gt;
    + 相对于RabitMQ，NSQ没有router这一层，功能也简化了不少，因此运维非常容易上手。&lt;br /&gt;
+ 消费者对应Channel&lt;br /&gt;
    + 如果channel没有消费，将会保留。如果同一个channel有多个消费者，则会轮训，按序分配给就绪（当前无处理任务）的消费者&lt;br /&gt;
+ 存储&lt;br /&gt;
    + Topic和Channel缓冲的数据相互独立，防止缓慢消费者造成对其他通道造成积压（同样适用于话题级别）。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;nsq-4&quot;&gt;NSQ安装（略）&lt;/h3&gt;

&lt;p&gt;http://nsq.io/deployment/installing.html&lt;br /&gt;
网上随便一个地方就能找到安装方式了&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;nsq-5&quot;&gt;NSQ使用&lt;/h3&gt;

&lt;p&gt;启动 nsqlookupd&lt;br /&gt;
&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nsqlookupd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;启动 nsqd&lt;br /&gt;
&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nsqd --lookupd-tcp-address=127.0.0.1:4160&lt;/code&gt;&lt;br /&gt;
&amp;gt;&lt;br /&gt;
&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nsqd --lookupd-tcp-address=127.0.0.1:4160 --tcp-address=0.0.0.0:4250 --http-address=0.0.0.0:4251 --data-path=/home/steve-3/nsq/data2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;启动 nsqadmin 浏览地址：http://127.0.0.1:4171/&lt;br /&gt;
&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nsqadmin --lookupd-http-address=127.0.0.1:4161&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;启动 nsq_to_file&lt;br /&gt;
&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nsq_to_file --topic=test --output-dir=./ --lookupd-http-address=127.0.0.1:4161&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;向客户端写入消息&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ curl -d &#39;hello world 1&#39; &#39;http://127.0.0.1:4151/put?topic=test&#39;
$ curl -d &#39;hello world 2&#39; &#39;http://127.0.0.1:4251/put?topic=test&#39;
&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;消息生命周期&lt;/h3&gt;

&lt;p&gt;NSQ提倡co-locating的部署方式, 也就是生产者与nsqd尽量在同一个实例环境中。生产者不需要负责发现其他的nsqd实例, 它们只管往自己的nsqd中投放消息。&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;具体的流程方式为:&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;生产者往本地的nsqd中发送消息.这个过程会开启一个连接, 并发送一个带有topic和消息体的PUB的命令到nsqd中. 我们假如是发送一个events的topic&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;events topic 会对消息进行copy,并多路发送到各个channel中, 我们假设有三个channel, 那么这个流程会如下图描述所示:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/nsq-message1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在channel中的每条消息会被放进队列中, 直到消息被worker所消费掉, 如果队列占用的内存超出限制, 消息会被写进硬盘&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nsqd节点会首先向nsqlookd节点广播它的位置信息, 一旦这些信息被nsqlookupd注册上, workers就会发现这些nsqd节点,包括这些节点的events topic&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;相关过程如下图&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/nsq-lookups.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;消息创建与接收&lt;/h3&gt;

&lt;p&gt;NSQ封了一个包：https://github.com/nsqio/go-nsq&lt;/p&gt;

&lt;p&gt;我们可以很方便的使用NSQ&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;发布者&lt;/h5&gt;

&lt;p&gt;消息发布，只能面向具体的nsqd服务进行。在API中对应的是nsq.Producer,直接初始化，就可以用了，非常简单：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// config是连接配置，作为发布者，不用刻意修改，在集群中足够使用&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewProducer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;127.0.0.1:4150&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//发布一条消息&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总结有以下两点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个topic的发布者只对应一个具体的NSQD，但可以多个发布者同时向一个NSQD发送消息，他们是N:1的关系。&lt;/li&gt;
  &lt;li&gt;NSQD与topic是1：N的关系。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;section-4&quot;&gt;消费者&lt;/h5&gt;

&lt;p&gt;消费者的理解要复杂一些，集群中最容易碰到无法接受到多节点消息的问题。结合官方多个文档及踩过的坑，需要注意：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;consumer要接收消息，是要连接到具体的nsqd服务的。通常我们能通过封装好的方法，基于lookupd服务来获取所有的nsqd服务地址并连接。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个消费者订阅的topic分布在哪些nsqd服务中，则会直接连接。nsqd之间是绝对不会互传topic的具体数据的。下图描绘了consumer与nsqd的关系：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/nsq-consumer.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;当多个nsqd服务都有相同的topic的时候，consumer要修改默认设置config.MaxInFlight才能连接。&lt;/li&gt;
  &lt;li&gt;consumer与topic没有直接联系，而是通过具体的channel接受数据。如果consumer退出，channel不会自动删除。 如果不再需要，需要通过http端口删除channel，否则很可能会导致磁盘空间不足。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;当消费者解析数据抛出错误后，channel会requene，但间隔时间将会越来越长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//最大允许向两台NSQD服务器接受消息，默认是1，要特别注意&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaxInFlight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test-channel1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 新建一个消费者&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//对消息进行处理的具体方法&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 添加消息处理的具体实现&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandlerFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//将消费者连接到具体的NSQD&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//if err := c1.ConnectToNSQD(&quot;127.0.0.1:4150&quot;); err != nil {&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//  panic(err)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//或者，如果启动了Lookupd服务，可通过nsqlookupd再分发给具体的nsqd&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConnectToNSQLookupd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;127.0.0.1:4161&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 简易实现&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;topicName&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;publish&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;topicName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test_channel&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandlerFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time:%v, Got a message: %v&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2006-01-02 15:04:05&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConnectToNSQD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;127.0.0.1:4150&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Could not connect&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-5&quot;&gt;集群环境&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;github.com/nsqio/go-nsq&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utils/waitwraper&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waitwraper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitWraper&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//接受消息&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//分别向不同的服务节点发送消息&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;node1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;localhost:4150&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)})&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;node2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;localhost:4152&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)})&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewProducer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//注意MaxInFlight的设置，默认只能接受一个节点&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaxInFlight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;consum&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hand&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandlerFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConnectToNSQLookupd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;localhost:4161&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-6&quot;&gt;这部分有以下几点需要注意：&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Producer断线后不会重连，需要自己手动重连，Consumer断线后会自动重连&lt;/li&gt;
  &lt;li&gt;Consumer的重连时间配置项有两个功能(这个设计必须吐槽一下，分开配置更好一点)
    &lt;ol&gt;
      &lt;li&gt;Consumer检测到与nsqd的连接断开后，每隔x秒向nsqd请求重连&lt;/li&gt;
      &lt;li&gt;Consumer每隔x秒，向nsqlookud进行http轮询，用来更新自己的nsqd地址目录&lt;/li&gt;
      &lt;li&gt;Consumer的重连时间默认是60s(…菜都凉了)，我改成了1s&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Consumer可以同时接收不同nsqd node的同名topic数据，为了避免混淆，就必须在客户端进行处理&lt;/li&gt;
  &lt;li&gt;在AddConurrentHandlers和 AddHandler中设置的接口回调是在另外的goroutine中执行的&lt;/li&gt;
  &lt;li&gt;Producer不能发布(Publish)空message，否则会导致panic&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-7&quot;&gt;总结&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;nsqd启动时，端口和数据存放要不同&lt;/li&gt;
  &lt;li&gt;消息发送必须指定具体的某个nsqd；而消费则可以通过lookupd获取再重定向&lt;/li&gt;
  &lt;li&gt;消费者接受数据时，要设置 config.MaxInFlight&lt;/li&gt;
  &lt;li&gt;channel在消费者退出后并不会删除，需要特别注意。如果紧紧是想利用nsq作为消息广播，不考虑离线数据保存，不妨考虑nats。&lt;/li&gt;
  &lt;li&gt;channel的名字，有很多限制，基本ASSCI字符+数字，以及点号”.”,下划线”_”。中文（其他非英语文字应该也不行）、以及空格、冒号”:”、横线”-“等都不得出现。&lt;/li&gt;
  &lt;li&gt;nsq大部分情况基本能满足我们作为消息队列的要求,而且性能与单点故障处理能力也比较出色
    &lt;ul&gt;
      &lt;li&gt;但它不适用的地方主要有:
        &lt;ol&gt;
          &lt;li&gt;有顺序要求的消息&lt;/li&gt;
          &lt;li&gt;不支持副本集的集群方式&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;
</description>
        <pubDate>Tue, 13 Feb 2018 16:42:44 +0800</pubDate>
        <link>http://www.xiaoh.me/2018/02/13/nsq-summary/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2018/02/13/nsq-summary/</guid>
        
        <category>NSQ</category>
        
        <category>Golang</category>
        
        <category>MQ</category>
        
        
      </item>
    
      <item>
        <title>关于创业</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;关于创业&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;之所以写这个主要是因为前一年主要精力都放在了一段创业上面，结果失败了，有感而发而已。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;什么是创业&lt;/h3&gt;

&lt;p&gt;百科里面是这么定义创业的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;创业是创业者对自己拥有的资源或通过努力对能够拥有的资源进行优化整合，从而创造出更大经济或社会价值的过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;为什么创业&lt;/h3&gt;

&lt;p&gt;我总是认为想要实现财富自由无外乎两种方式，一是在大厂好好干往上爬，拿到股份；二是创业。&lt;/p&gt;

&lt;p&gt;而因为这几年的工作经历，绝大多数时间是在创业公司的 ，在各个方面发展还算均衡，所以我更喜欢走创业这条路。&lt;/p&gt;

&lt;p&gt;而创业也不是那么容易的 ，前期要投入很多的资源和精力，而且纵然这些都可以保障，也不能说明创业就可以成功，还要看市场和运营，总之创业不只是一个想法，里面的东西还有很多，如果你走在创业的路上，祝你成功；如果你在考虑是否进行创业，我劝你三思而后行。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;关于扯弹&lt;/h3&gt;

&lt;p&gt;说这些都是因为我的一段创业经历，最后以失败告终的缘故。&lt;/p&gt;

&lt;p&gt;我们创业的项目就是“扯弹”，这个名字起得很有内涵，因为我们是在做一个手机的APP，可以观看各种弹幕的社交产品，所以扯弹这个名字真的很恰到，并且关联到扯蛋这个话题的话，广泛的关注度也是有的。&lt;/p&gt;

&lt;p&gt;因为合伙人在影视娱乐领域有一些资源，可以在这个领域做推广和运营，而我对弹幕APP这个方面也有所耕耘，所以我们选择了一同在垂直于电影娱乐领域的社交APP进行了第一次创业。&lt;/p&gt;

&lt;p&gt;在创业过程中，我们真的每个人人尽其事，合伙人做产品，设计，财务工作，我来做管理，后台等工作，每个人忙的热火朝天，甚至有段时间我们的作息是每晚工作到两三点之后8点还得爬起来，更有甚者，有的时候为了一个需求，我们忙到早上五点，睡三个小时还得爬起来继续工作。&lt;/p&gt;

&lt;p&gt;当前扯弹这个项目已经关闭了，考究其失败的原因，我感觉可以列为如下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;产品定位
    &lt;ul&gt;
      &lt;li&gt;产品定位这个点其实和市场和技术发展有很大的关系，扯弹主要在电影院去看电影的弹幕，这个逻辑细想是有问题的，我在看电影的时候不可能会拖着手机屏幕在看弹幕，而这个需求其实是有价值的，日后VR发展普及之后我们可以在这个场景下面做功能，实际上产品是可以的，只是定位不太明确。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;资源不足
    &lt;ul&gt;
      &lt;li&gt;这个是硬伤，因为资源不足，导致我们不能使用全职的人来进行相关工作，导致后期的工期拖长，导致不能按时上线产品进行推广等工作。&lt;/li&gt;
      &lt;li&gt;另一方面，在推广的过程中也能发现，虽然有一定的资源，但是推广资源明显不足，甚至产品在后期并没有做更多的推广工作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺乏沟通
    &lt;ul&gt;
      &lt;li&gt;这个实际上是因为合伙创业的缘故，我和合伙人离得比较远，平时在工作中主要以微信电话等途径进行沟通，从后期结果看来我们的沟通太少，实则应该至少每周都要举行一次面对面的商讨。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;需求变更
    &lt;ul&gt;
      &lt;li&gt;在实现过程中，我们进行了两次比较大的产品需求变更，这个在开发过程中是相当费时费力的。而由于合伙人对开发工作的不了解，总觉得这也没什么，所以导致很多矛盾的产生。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上在开发一款产品，进行创业的过程中，会遇到各种各样的问题，以上只是我觉得比较重要的几点，也是我在这次创业过程中凸显的几点。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;创业建议&lt;/h3&gt;

&lt;p&gt;如以上我说的失败的原因，其实可以总结几点建议&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;产品定位
    &lt;ul&gt;
      &lt;li&gt;很少有人会做到乔布斯那种引领用户的需求，而我们绝大多数人只是迎合市场，适应用户的选择而已，所以在产品的定位上面一定要斟酌。&lt;/li&gt;
      &lt;li&gt;另一方面，在产品的技术选型，市场发展一定要做好规划，可以承受多长时间的无用户状态等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;创业资源
    &lt;ul&gt;
      &lt;li&gt;这一点不仅是金钱上的资源，从人脉，从市场，从运营等方面都需要有相当的资源。&lt;/li&gt;
      &lt;li&gt;从这一点来讲，如果你自己创业，势必先了解自己在这几个综合方面是否有相当的资源，或者你有合伙人，你们几个综合的资源是否满足产品的发展需要。&lt;/li&gt;
      &lt;li&gt;一般来讲，创业前期对金钱的需求会很大，这个时代，效率总是第一位的，如果你有想法，那就尽快的实现出来，所以前期就得投钱，快速实现，快速验证市场需求，这样也比长线发展更有效。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;沟通
    &lt;ul&gt;
      &lt;li&gt;如果你是合伙人机制，那么你们的沟通一定要频繁，实时让对方掌控总体的进度和风险。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;需求
    &lt;ul&gt;
      &lt;li&gt;实际上在创业过程中，需求是不可能不变的，但这种变化一定要做到可控。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;合伙人
    &lt;ul&gt;
      &lt;li&gt;多个合伙人创业有相当的优势，首先多个人的领域一定有不同，合起来可以让大家的总实力变强。&lt;/li&gt;
      &lt;li&gt;多个人可以相互探讨，三个臭皮匠顶一个诸葛亮也是有一定道理的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;创业收获&lt;/h3&gt;

&lt;p&gt;虽然这次创业失败，但也并不是一无所获，首先在创业过程中我体会到了做一个决策者的心里状态，更明白在工作中，如何体现自己的价值，当一个普通员工可以坐在决策者的位置来考虑问题的时候，那么这个员工一定更有价值。&lt;/p&gt;

&lt;p&gt;其次，在创业最累的时候，我们仍然能够坚持住，每晚工作都特别晚，这完全没有触碰到我们的真正的临界点，所以说，创业真正激发了我们最大的能量，我觉得我能做到更多的东西了。他给了我无限的信心。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;创业总结&lt;/h3&gt;

&lt;p&gt;总之，如果有机会的话 ， 我仍然会走创业这条路，他能够发挥你身体最大的潜能，当人们朝着自己的梦想努力的时候，你都想象不到自己会做到什么。&lt;/p&gt;

&lt;p&gt;共勉！&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;
</description>
        <pubDate>Sun, 11 Feb 2018 21:26:25 +0800</pubDate>
        <link>http://www.xiaoh.me/2018/02/11/about-startup/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2018/02/11/about-startup/</guid>
        
        <category>Startup</category>
        
        
      </item>
    
      <item>
        <title>Nginx配置详解</title>
        <description>&lt;h2 id=&quot;nginx&quot;&gt;nginx概述&lt;/h2&gt;

&lt;p&gt;nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。&lt;/p&gt;

&lt;p&gt;这里主要通过三个方面简单介绍nginx&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;反向代理&lt;/li&gt;
  &lt;li&gt;负载均衡&lt;/li&gt;
  &lt;li&gt;nginx配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nginx安装就不说了，随便找个地方google一下即可&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;反向代理&lt;/h2&gt;

&lt;h5 id=&quot;section-1&quot;&gt;关于代理&lt;/h5&gt;

&lt;p&gt;说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；&lt;/p&gt;

&lt;p&gt;此时就设计到两个角色，一个是被代理角色，一个是目标角色，被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程；如同生活中的专卖店~客人到adidas专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是adidas厂家，目标角色就是用户&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/nginx-about-proxy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;正向代理&lt;/h5&gt;

&lt;p&gt;说反向代理之前，我们先看看正向代理，正向代理也是大家最常接触的到的代理模式，我们会从两个方面来说关于正向代理的处理模式，分别从软件方面和生活方面来解释一下什么叫正向代理&lt;/p&gt;

&lt;p&gt;在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作翻墙进行访问，翻墙的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！&lt;/p&gt;

&lt;p&gt;上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；&lt;strong&gt;正向代理模式屏蔽或者隐藏了真实客户端信息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/nginx-zheng-proxy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;反向代理&lt;/h5&gt;

&lt;p&gt;明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我大天朝的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用nginx进行反向代理实现的，并且通过封装nginx和其他的组件之后起了个高大上的名字：Tengine，有兴趣的童鞋可以访问Tengine的官网查看具体的信息：http://tengine.taobao.org/&lt;/p&gt;

&lt;p&gt;那么反向代理具体是通过什么样的方式实现的分布式的集群操作呢，我们先看一个示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/nginx-fan-proxy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，nginx扮演的就是一个反向代理角色&lt;/p&gt;

&lt;p&gt;反向代理，主要用于服务器集群分布式部署的情况下，&lt;strong&gt;反向代理隐藏了服务器的信息！&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;项目场景&lt;/h5&gt;

&lt;p&gt;通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/nginx-proxy-using.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-5&quot;&gt;负载均衡&lt;/h2&gt;

&lt;p&gt;我们已经明确了所谓代理服务器的概念，那么接下来，nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？&lt;/p&gt;

&lt;p&gt;这里提到的客户端发送的、nginx反向代理服务器接收到的请求数量，就是我们说的负载量&lt;/p&gt;

&lt;p&gt;请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则&lt;/p&gt;

&lt;p&gt;所以~将服务器接收到的请求按照规则分发的过程，称为负载均衡。&lt;/p&gt;

&lt;p&gt;负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/nginx-load-balance.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;nginx-1&quot;&gt;nginx支持的负载均衡调度算法方式如下&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;weight轮询（默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在nginx作为静态服务器的情况下提高缓存效率。同样要注意nginx默认不支持这种调度算法，要使用的话需要安装nginx的hash软件包&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上在做负载均衡的时候，直接给server都写到upstream里面，配置一下weight即可，nginx会根据配置的权重来分配请求&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;upstream backend {
        server localhost:8091 weight=1;
        server localhost:8092 weight=2;
        server localhost:8093 weight=3;
        server localhost:8094 weight=4;
}

server {
        listen 8090;
        server_name _;

        charset utf-8;
        root  &quot;/Users/xiaoh/tmp&quot;;

        location / {
               proxy_pass http://backend;
               proxy_set_header Host $host;
               proxy_set_header X-Real-IP $remote_addr;
               proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
               proxy_set_header X-Forwarded-Proto $scheme;
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;nginx-2&quot;&gt;Nginx配置&lt;/h2&gt;

&lt;p&gt;nginx是一个功能非常强大的web服务器加反向代理服务器，同时又是邮件服务器等等&lt;/p&gt;

&lt;p&gt;在项目使用中，使用最多的三个核心功能是反向代理、负载均衡和静态服务器&lt;/p&gt;

&lt;p&gt;这三个不同的功能的使用，都跟nginx的配置密切相关，nginx服务器的配置信息主要集中在nginx.conf这个配置文件中，并且所有的可配置选项大致分为以下几个部分&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;main                                # 全局配置

events {                            # nginx工作模式配置

}

http {                                # http设置
    ....

    server {                        # 服务器主机配置
        ....
        location {                    # 路由配置
            ....
        }

        location path {
            ....
        }

        location otherpath {
            ....
        }
    }

    server {
        ....

        location {
            ....
        }
    }

    upstream name {                    # 负载均衡配置
        ....
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如上述配置文件所示，主要由6个部分组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;main：用于进行nginx全局信息的配置&lt;/li&gt;
  &lt;li&gt;events：用于nginx工作模式的配置&lt;/li&gt;
  &lt;li&gt;http：用于进行http协议信息的一些配置&lt;/li&gt;
  &lt;li&gt;server：用于进行服务器访问信息的配置&lt;/li&gt;
  &lt;li&gt;location：用于进行访问路由的配置&lt;/li&gt;
  &lt;li&gt;upstream：用于进行负载均衡的配置&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;main&quot;&gt;main模块&lt;/h5&gt;

&lt;p&gt;观察下面的配置代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# user nobody nobody;
worker_processes 2;
# error_log logs/error.log
# error_log logs/error.log notice
# error_log logs/error.log info
# pid logs/nginx.pid
worker_rlimit_nofile 1024;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述配置都是存放在main全局配置模块中的配置项&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;user用来指定nginx worker进程运行用户以及用户组，默认nobody账号运行&lt;/li&gt;
  &lt;li&gt;worker_processes指定nginx要开启的子进程数量，运行过程中监控每个进程消耗内存(一般几M~几十M不等)根据实际情况进行调整，通常数量是CPU内核数量的整数倍&lt;/li&gt;
  &lt;li&gt;error_log定义错误日志文件的位置及输出级别【debug / info / notice / warn / error / crit】&lt;/li&gt;
  &lt;li&gt;pid用来指定进程id的存储文件的位置&lt;/li&gt;
  &lt;li&gt;worker_rlimit_nofile用于指定一个进程可以打开最多文件数量的描述&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;event-&quot;&gt;event 模块&lt;/h5&gt;

&lt;p&gt;上干货&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;event {
    worker_connections 1024;
    multi_accept on;
    use epoll;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述配置是针对nginx服务器的工作模式的一些操作配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;worker_connections 指定最大可以同时接收的连接数量，这里一定要注意，最大连接数量是和worker processes共同决定的。&lt;/li&gt;
  &lt;li&gt;multi_accept 配置指定nginx在收到一个新连接通知后尽可能多的接受更多的连接&lt;/li&gt;
  &lt;li&gt;use epoll 配置指定了线程轮询的方法，如果是linux2.6+，使用epoll，如果是BSD如Mac请使用Kqueue&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;http&quot;&gt;http模块&lt;/h5&gt;

&lt;p&gt;作为web服务器，http模块是nginx最核心的一个模块，配置项也是比较多的，项目中会设置到很多的实际业务场景，需要根据硬件信息进行适当的配置，常规情况下，使用默认配置即可！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http {
    ##
    # 基础配置
    ##

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    # server_tokens off;

    # server_names_hash_bucket_size 64;
    # server_name_in_redirect off;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL证书配置
    ##

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
    ssl_prefer_server_ciphers on;

    ##
    # 日志配置
    ##

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip 压缩配置
    ##

    gzip on;
    gzip_disable &quot;msie6&quot;;

    # gzip_vary on;
    # gzip_proxied any;
    # gzip_comp_level 6;
    # gzip_buffers 16 8k;
    # gzip_http_version 1.1;
    # gzip_types text/plain text/css application/json application/javascript
    text/xml application/xml application/xml+rss text/javascript;

    ##
    # 虚拟主机配置
    ##

    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;section-6&quot;&gt;基础配置&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sendfile on：配置on让sendfile发挥作用，将文件的回写过程交给数据缓冲去去完成，而不是放在应用中完成，这样的话在性能提升有有好处
tc_nopush on：让nginx在一个数据包中发送所有的头文件，而不是一个一个单独发
tcp_nodelay on：让nginx不要缓存数据，而是一段一段发送，如果数据的传输有实时性的要求的话可以配置它，发送完一小段数据就立刻能得到返回值，但是不要滥用哦

keepalive_timeout 10：给客户端分配连接超时时间，服务器会在这个时间过后关闭连接。一般设置时间较短，可以让nginx工作持续性更好
client_header_timeout 10：设置请求头的超时时间
client_body_timeout 10:设置请求体的超时时间
send_timeout 10：指定客户端响应超时时间，如果客户端两次操作间隔超过这个时间，服务器就会关闭这个链接

limit_conn_zone $binary_remote_addr zone=addr:5m ：设置用于保存各种key的共享内存的参数，
limit_conn addr 100: 给定的key设置最大连接数

server_tokens：虽然不会让nginx执行速度更快，但是可以在错误页面关闭nginx版本提示，对于网站安全性的提升有好处哦
include /etc/nginx/mime.types：指定在当前文件中包含另一个文件的指令
default_type application/octet-stream：指定默认处理的文件类型可以是二进制
type_hash_max_size 2048：混淆数据，影响三列冲突率，值越大消耗内存越多，散列key冲突率会降低，检索速度更快；值越小key，占用内存较少，冲突率越高，检索速度变慢
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;section-7&quot;&gt;日志配置&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;access_log logs/access.log：设置存储访问记录的日志
error_log logs/error.log：设置存储记录错误发生的日志
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;ssl&quot;&gt;SSL证书加密&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssl_protocols：指令用于启动特定的加密协议，nginx在1.1.13和1.0.12版本后默认是ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2，TLSv1.1与TLSv1.2要确保OpenSSL &amp;gt;= 1.0.1 ，SSLv3 现在还有很多地方在用但有不少被攻击的漏洞。
ssl prefer server ciphers：设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;section-8&quot;&gt;压缩配置&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gzip 是告诉nginx采用gzip压缩的形式发送数据。这将会减少我们发送的数据量。
gzip_disable 为指定的客户端禁用gzip功能。我们设置成IE6或者更低版本以使我们的方案能够广泛兼容。
gzip_static 告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件（在这个例子中被注释掉了），从而允许你使用最高压缩比，这样nginx就不用再压缩这些文件了（想要更详尽的gzip_static的信息，请点击这里）。
gzip_proxied 允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求。
gzip_min_length 设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度。
gzip_comp_level 设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置。
gzip_type 设置需要压缩的数据格式。上面例子中已经有一些了，你也可以再添加更多的格式。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;section-9&quot;&gt;文件缓存配置&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open_file_cache 打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉。
open_file_cache_valid 在open_file_cache中指定检测正确信息的间隔时间。
open_file_cache_min_uses 定义了open_file_cache中指令参数不活动时间期间里最小的文件数。
open_file_cache_errors 指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;server&quot;&gt;server模块&lt;/h5&gt;

&lt;p&gt;srever模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机，也就是一个虚拟服务器的配置信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    listen        80;
    server_name localhost    192.168.1.100;
    root        /nginx/www;
    index        index.php index.html index.html;
    charset        utf-8;
    access_log    logs/access.log;
    error_log    logs/error.log;
    ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;核心配置信息如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;server：一个虚拟主机的配置，一个http中可以配置多个server&lt;/li&gt;
  &lt;li&gt;server_name：用力啊指定ip地址或者域名，多个配置之间用空格分隔&lt;/li&gt;
  &lt;li&gt;root：表示整个server虚拟主机内的根目录，所有当前主机中web项目的根目录&lt;/li&gt;
  &lt;li&gt;index：用户访问web网站时的全局首页&lt;/li&gt;
  &lt;li&gt;charset：用于设置www/路径中配置的网页的默认编码格式&lt;/li&gt;
  &lt;li&gt;access_log：用于指定该虚拟主机服务器中的访问记录日志存放路径&lt;/li&gt;
  &lt;li&gt;error_log：用于指定该虚拟主机服务器中访问错误日志的存放路径&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;location&quot;&gt;location模块&lt;/h5&gt;

&lt;p&gt;location模块是nginx配置中出现最多的一个配置，主要用于配置路由访问信息&lt;/p&gt;

&lt;p&gt;在路由访问信息配置中关联到反向代理、负载均衡等等各项功能，所以location模块也是一个非常重要的配置模块&lt;/p&gt;

&lt;h6 id=&quot;section-10&quot;&gt;基本配置&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location / {
    root    /nginx/www;
    index    index.php index.html index.htm;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;location /：表示匹配访问根目录&lt;/li&gt;
  &lt;li&gt;root：用于指定访问根目录时，访问虚拟主机的web目录&lt;/li&gt;
  &lt;li&gt;index：在不指定访问具体资源时，默认展示的资源文件列表&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-11&quot;&gt;反向代理配置方式&lt;/h6&gt;

&lt;p&gt;通过反向代理代理服务器访问模式，通过proxy_set配置让客户端访问透明化&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location / {
    proxy_pass http://localhost:8888;
    proxy_set_header X-real-ip $remote_addr;
    proxy_set_header Host $http_host;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;uwsgi&quot;&gt;uwsgi配置&lt;/h6&gt;

&lt;p&gt;wsgi模式下的服务器配置访问方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location / {
    include uwsgi_params;
    uwsgi_pass localhost:8888
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;upstream&quot;&gt;upstream模块&lt;/h5&gt;

&lt;p&gt;upstream模块主要负责负载均衡的配置，通过默认的轮询调度方式来分发请求到后端服务器&lt;/p&gt;

&lt;p&gt;简单的配置方式如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;upstream name {
    ip_hash;
    server 192.168.1.100:8000;
    server 192.168.1.100:8001 down;
    server 192.168.1.100:8002 max_fails=3;
    server 192.168.1.100:8003 fail_timeout=20s;
    server 192.168.1.100:8004 max_fails=3 fail_timeout=20s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;核心配置信息如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ip_hash：指定请求调度算法，默认是weight权重轮询调度，可以指定&lt;/li&gt;
  &lt;li&gt;server host:port：分发服务器的列表配置
    &lt;ul&gt;
      &lt;li&gt;down：表示该主机暂停服务&lt;/li&gt;
      &lt;li&gt;max_fails：表示失败最大次数，超过失败最大次数暂停服务&lt;/li&gt;
      &lt;li&gt;fail_timeout：表示如果请求受理失败，暂停指定的时间之后重新发起请求&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nginx-3&quot;&gt;Nginx遇到的坑&lt;/h2&gt;

&lt;p&gt;多个server监听同一个端口，但不同的Host，结果总是不能精准的匹配Host，而是总是到前面的server里面&lt;/p&gt;

&lt;p&gt;后来我直接给server对调了一下，按照逻辑，应该是First In Last Out形势，配置的话应该是按顺序处理Server的，之后从后处理的Server开始匹配，如果匹配则返回。&lt;/p&gt;

&lt;p&gt;多个配置文件，则是通过配置文件的名称顺序进行读取的，所以会先路由后面的server&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;
</description>
        <pubDate>Thu, 08 Feb 2018 04:55:07 +0800</pubDate>
        <link>http://www.xiaoh.me/2018/02/08/nginx-config/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2018/02/08/nginx-config/</guid>
        
        <category>nginx</category>
        
        
      </item>
    
      <item>
        <title>2017年终总结之展望2018</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;我的2017&lt;/h1&gt;

&lt;p&gt;2017年即将过去，在这一年， 经历了创业失败，换了工作两件大事，感觉变化还是蛮大的！&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;创业失败&lt;/h3&gt;

&lt;p&gt;这次创业经过了一年的时间，作为技术合伙人，在这一年里面，各种事情全部需要参与，架构，开发，运维，甚至产品，交互，APP端的逻辑等各种乱七八糟的事情都在参与。创业真的是太锻炼人了。&lt;/p&gt;

&lt;p&gt;创业的这段时间，对身体真的是一个非常大的考验，基本上每天晚上要忙到两三点，甚至有的时候需要忙到早上五点，有的时候真的觉得快要受不了了，但是创业真的有种魔力，在最艰难的时候总能扛过去，甚至每天晚上两三点，第二天依然能够爬起来继续战斗。&lt;/p&gt;

&lt;p&gt;创业由于身份的改观，对待工作的态度完全也不一样了，以前真的是老板给任务就干，干完干不完都不纠结，只觉得技术厉害就可以了，但现在看事情都不会这样，现在更希望员工的态度端正，工作能力到时其次的，这些都是可以在工作中进步的，但是态度能够保证你工作起来是否有希望。&lt;/p&gt;

&lt;p&gt;这次创业的失败也真的是很郁闷，本来想着在全力做这个产品，但合伙人中途退出也是没有办法的事情，事情进行不下去也只能考虑放弃了。&lt;/p&gt;

&lt;p&gt;创业的失败也是多方面的因素导致的，首先说自己，对功能产品的开发时间估算有较大的问题，由于几个技术都是兼职的形式，根本没有办法保证其开发的时间，所以总是在时间上面延后一些，但自从加入了敏捷的开发节奏之后，整体上要好很多。其次是产品的定位不是很合理，这是因为前期对产品的市场没有做过多的研究，而且对产品的附属技术有较大的乐观估计，所以导致了产品的定位在现阶段没有完全展示出来。还有就是运营和推广的不利，实际上，产品压根没有进行任何的推广工作，也是没有办法的事情，前期钱少就不多说了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;换工作&lt;/h3&gt;

&lt;p&gt;其实换工作也是很早就有的想法，这次只是挨到了这次创业了，本来想着可以在创业的路上走的更远，但是没有办法，既然没有坚持，也说不准是因为自己还没有准备好。&lt;/p&gt;

&lt;p&gt;这次也是赶上了现在的领导的赏识还有公司的业务比较看好，希望以后是一个好的结果吧。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;技术栈&lt;/h3&gt;

&lt;p&gt;这次技术栈也算是一个比较大的改观，目前主要在做Golang，虽然已经接触了很长时间，但是作为主要技术栈的工作还是这次换工作的最大一点。&lt;/p&gt;

&lt;p&gt;希望以后可以继续吧。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;2018展望&lt;/h1&gt;

&lt;p&gt;在这里也展望一下2018年，给自己定几个目标吧&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[ ] 在天津买房&lt;/li&gt;
  &lt;li&gt;[ ] 买个车&lt;/li&gt;
  &lt;li&gt;[ ] 体重在现有基础上减少10公斤&lt;/li&gt;
  &lt;li&gt;[ ] 可以全家一起出游一次&lt;/li&gt;
  &lt;li&gt;[ ] 至少做一款自己喜欢的应用&lt;/li&gt;
  &lt;li&gt;[ ] 更深一步理解Golang&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;希望2018年全家健康 ^V^&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jan 2018 04:12:19 +0800</pubDate>
        <link>http://www.xiaoh.me/2018/01/01/2017-summary/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2018/01/01/2017-summary/</guid>
        
        <category>2017</category>
        
        <category>总结</category>
        
        <category>2018</category>
        
        <category>展望</category>
        
        
      </item>
    
      <item>
        <title>搭建GIT仓库服务器方法</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;目录&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#summary&quot;&gt;简介&lt;/a&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#installgit&quot;&gt;安装GIT&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#adduser&quot;&gt;创建用户&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#authorized&quot;&gt;创建证书登录&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#initgit&quot;&gt;初始化GIT仓库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#loginshell&quot;&gt;禁用shell登录&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#clone&quot;&gt;克隆远程仓库&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#help&quot;&gt;帮助&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#links&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;从几年前在使用.NET语言的时候使用正则，到现在，有的时候用的多一些，有的时候用的比较少，不过，都没有离开正则，毕竟工作中很多内容都是在和字符串打交道。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;summary&quot;&gt;&lt;a href=&quot;#summary&quot;&gt;简介&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。&lt;/p&gt;

&lt;p&gt;搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。&lt;/p&gt;

&lt;p&gt;假设你已经有&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt;权限的用户账号，下面，正式开始安装。&lt;/p&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;gitinstall&quot;&gt;&lt;a href=&quot;#install&quot;&gt;安装GIT&lt;/a&gt;&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;adduser&quot;&gt;&lt;a href=&quot;#adduser&quot;&gt;创建用户&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;用户,用来运行&lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo adduser git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;authorized&quot;&gt;&lt;a href=&quot;#authorized&quot;&gt;创建证书登录&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;收集所有需要登录的用户的公钥，就是他们自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;id_rsa.pub&lt;/code&gt;文件，把所有公钥导入到&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/git/.ssh/authorized_keys&lt;/code&gt;文件里，一行一个。&lt;/p&gt;

&lt;h5 id=&quot;gitinit&quot;&gt;&lt;a href=&quot;#init&quot;&gt;初始化GIT仓库&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo git init --bare sample.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Git&lt;/code&gt;就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的&lt;code class=&quot;highlighter-rouge&quot;&gt;Git&lt;/code&gt;仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的&lt;code class=&quot;highlighter-rouge&quot;&gt;Git&lt;/code&gt;仓库通常都以&lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;结尾。然后，把&lt;code class=&quot;highlighter-rouge&quot;&gt;owner&lt;/code&gt;改为&lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo chown -R git:git sample.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;shelllogin&quot;&gt;&lt;a href=&quot;#login&quot;&gt;禁用shell登录&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;出于安全考虑，第二步创建的&lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;用户不允许登录&lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt;，这可以通过编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt;文件完成。找到类似下面的一行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git:x:1001:1001:,,,:/home/git:/bin/bash
改为
git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，&lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;用户可以正常通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;，但无法登录&lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt;，因为我们为&lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;用户指定的&lt;code class=&quot;highlighter-rouge&quot;&gt;git-shell&lt;/code&gt;每次一登录就自动退出。&lt;/p&gt;

&lt;h5 id=&quot;clone&quot;&gt;&lt;a href=&quot;#clone&quot;&gt;克隆远程仓库&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;现在，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt;命令克隆远程仓库了，在各自的电脑上运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git clone git@server:/srv/sample.git
Cloning into &lt;span class=&quot;s1&quot;&gt;&#39;sample&#39;&lt;/span&gt;...
warning: You appear to have cloned an empty repository.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;剩下的推送就简单了&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;help&quot;&gt;&lt;a href=&quot;#help&quot;&gt;帮助&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;由于上面的操作比较麻烦,我使用beego的架构写了一个帮助的项目,其中提供了,关于SSH KEY的相关操作,提供了和仓库的相关操作,项目比较简单,目前被我放到了github上面,链接地址如下:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/pmars/gitService&quot;&gt;https://github.com/pmars/gitService&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;links&quot;&gt;&lt;a href=&quot;#links&quot;&gt;参考资料&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000&quot;&gt;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;

</description>
        <pubDate>Fri, 14 Apr 2017 04:27:20 +0800</pubDate>
        <link>http://www.xiaoh.me/2017/04/14/git-service/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2017/04/14/git-service/</guid>
        
        <category>git</category>
        
        
      </item>
    
      <item>
        <title>Redis进阶教程</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;目录&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#summary&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#sort&quot;&gt;排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#transaction&quot;&gt;事物&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pipeline&quot;&gt;管道&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#subpub&quot;&gt;发布/订阅&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#persistence&quot;&gt;持久化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#master-slave&quot;&gt;主从复制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#swapmemory&quot;&gt;虚拟内存&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#documents&quot;&gt;文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于Redis的简述可以查看以前的博客 &lt;a href=&quot;http://www.xiaoh.me/2015/12/17/redis-summary/&quot;&gt;http://www.xiaoh.me/2015/12/17/redis-summary/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;summary&quot;&gt;&lt;a href=&quot;#summary&quot;&gt;简介&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Redis是一个开源的&lt;code class=&quot;highlighter-rouge&quot;&gt;key-value&lt;/code&gt;数据库。它又经常被认为是一个数据结构服务器。因为它的&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;不仅包括基本的&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;类型还有&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt; ,&lt;code class=&quot;highlighter-rouge&quot;&gt;sorted set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;类型。当然这些类型的元素也都是&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;类型。也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;这些集合类型也只能包含&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;类型。&lt;/p&gt;

&lt;p&gt;你可以在这些类型上做很多原子性的操作。比如对一个字符&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;追加字符串（&lt;code class=&quot;highlighter-rouge&quot;&gt;APPEND&lt;/code&gt;命令）。加加或者减减一个数字字符串(&lt;code class=&quot;highlighter-rouge&quot;&gt;INCR&lt;/code&gt;命令，当然是按整数处理的).可以对&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;类型进行&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;,或者&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt;元素操作（可以模拟栈和队列）。对于&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;类型可以进行一些集合相关操作 (&lt;code class=&quot;highlighter-rouge&quot;&gt;intersection union difference&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcache&lt;/code&gt;也有类似与&lt;code class=&quot;highlighter-rouge&quot;&gt;++&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt;的命令。不过&lt;code class=&quot;highlighter-rouge&quot;&gt;memcache&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;只包括&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;类型。远没有&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;类型丰富。和&lt;code class=&quot;highlighter-rouge&quot;&gt;memcahe&lt;/code&gt;一样为了性能。&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的数据通常都是放到内存中的。当然&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;可以每间隔一定时间将内存中数据写入到磁盘以防止数据丢失。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;也支持主从复制机制（&lt;code class=&quot;highlighter-rouge&quot;&gt;master-slave replication&lt;/code&gt;）。&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的其他特性包括简单的事务支持和发布订阅(&lt;code class=&quot;highlighter-rouge&quot;&gt;pub/sub&lt;/code&gt;)通道功能,而且&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;配置管理非常简单。还有各种语言版本的开源客户端类库。&lt;/p&gt;

&lt;p&gt;一些简单的使用方法可以参照以前的博客&lt;a href=&quot;http://www.xiaoh.me/2015/12/17/redis-summary/&quot;&gt;http://www.xiaoh.me/2015/12/17/redis-summary/&lt;/a&gt;，这里就不再嗷述。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;sort&quot;&gt;&lt;a href=&quot;#sort&quot;&gt;排序&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;支持对&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;sorted set&lt;/code&gt;元素的排序。排序命令是&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt; 完整的命令格式如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; help sort

  SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]
  summary: Sort the elements in a list, set or sorted set
  since: 1.0.0
  group: generic

127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;sort-key&quot;&gt;sort key&lt;/h5&gt;

&lt;p&gt;这种是直接对一个数据结构进行排序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; rpush l 3 4 1 5 2
(integer) 5
127.0.0.1:6379&amp;gt; lrange l 0 5
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;1&quot;
4) &quot;5&quot;
5) &quot;2&quot;
127.0.0.1:6379&amp;gt; sort l
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对set进行添加变量的时候，他会自动排序，所以用不到sort这种简单的功能。&lt;/p&gt;

&lt;h5 id=&quot;ascdesc-alpha&quot;&gt;[ASC|DESC] [ALPHA]&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;默认的排序方式（&lt;code class=&quot;highlighter-rouge&quot;&gt;asc&lt;/code&gt;）是从小到大排的,当然也可以按照逆序或者按字符顺序排。逆序可以加上&lt;code class=&quot;highlighter-rouge&quot;&gt;desc&lt;/code&gt;选项，想按字母顺序排可以加&lt;code class=&quot;highlighter-rouge&quot;&gt;alpha&lt;/code&gt;选项，当然&lt;code class=&quot;highlighter-rouge&quot;&gt;alpha&lt;/code&gt;可以和&lt;code class=&quot;highlighter-rouge&quot;&gt;desc&lt;/code&gt;一起用。下面是个按字母顺序排的例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; lpush l xiaoh huo xingming beijing changping
(integer) 5
127.0.0.1:6379&amp;gt; lrange l 0 5
1) &quot;changping&quot;
2) &quot;beijing&quot;
3) &quot;xingming&quot;
4) &quot;huo&quot;
5) &quot;xiaoh&quot;
127.0.0.1:6379&amp;gt; sort l alpha
1) &quot;beijing&quot;
2) &quot;changping&quot;
3) &quot;huo&quot;
4) &quot;xiaoh&quot;
5) &quot;xingming&quot;
127.0.0.1:6379&amp;gt; sort l alpha desc
1) &quot;xingming&quot;
2) &quot;xiaoh&quot;
3) &quot;huo&quot;
4) &quot;changping&quot;
5) &quot;beijing&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;by-pattern&quot;&gt;[BY pattern]&lt;/h5&gt;

&lt;p&gt;Redis 支持将集合元素内容按照给定的&lt;code class=&quot;highlighter-rouge&quot;&gt;pattern&lt;/code&gt;进行组合成新的KEY, 并按照新的KEY的对应内容进行排序，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; lpush l e s g f a
(integer) 5
127.0.0.1:6379&amp;gt; lrange l 0 9
1) &quot;a&quot;
2) &quot;f&quot;
3) &quot;g&quot;
4) &quot;s&quot;
5) &quot;e&quot;
127.0.0.1:6379&amp;gt; sort l alpha
1) &quot;a&quot;
2) &quot;e&quot;
3) &quot;f&quot;
4) &quot;g&quot;
5) &quot;s&quot;
127.0.0.1:6379&amp;gt; set namea 4
OK
127.0.0.1:6379&amp;gt; set namee 5
OK
127.0.0.1:6379&amp;gt; set namef 3
OK
127.0.0.1:6379&amp;gt; set nameg 1
OK
127.0.0.1:6379&amp;gt; set names 2
OK
127.0.0.1:6379&amp;gt; sort l by name*
1) &quot;g&quot;
2) &quot;s&quot;
3) &quot;f&quot;
4) &quot;a&quot;
5) &quot;e&quot;
127.0.0.1:6379&amp;gt; set namea xiaoh
OK
127.0.0.1:6379&amp;gt; set namee me
OK
127.0.0.1:6379&amp;gt; set namef huo
OK
127.0.0.1:6379&amp;gt; set nameg blog
OK
127.0.0.1:6379&amp;gt; set names xingming
OK
127.0.0.1:6379&amp;gt; sort l by name* alpha
1) &quot;g&quot;
2) &quot;f&quot;
3) &quot;e&quot;
4) &quot;a&quot;
5) &quot;s&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上实验了数字和字母的对应KEY，可以看出，在生成对应的新kEY之后，按照对应的内容进行了排序，并且返回的是原来的key的排序。&lt;/p&gt;

&lt;h5 id=&quot;get-pattern&quot;&gt;[GET PATTERN]&lt;/h5&gt;

&lt;p&gt;上面的方法返回的是原始的数据内容，如果想获得新的KEY对应的值（也就是进行排序的KEY）可以使用 GET PATTERN&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; sort l by name* alpha get name*
1) &quot;blog&quot;
2) &quot;huo&quot;
3) &quot;me&quot;
4) &quot;xiaoh&quot;
5) &quot;xingming&quot;
127.0.0.1:6379&amp;gt; sort l by name* alpha get name* get #
 1) &quot;blog&quot;
 2) &quot;g&quot;
 3) &quot;huo&quot;
 4) &quot;f&quot;
 5) &quot;me&quot;
 6) &quot;e&quot;
 7) &quot;xiaoh&quot;
 8) &quot;a&quot;
 9) &quot;xingming&quot;
10) &quot;s&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GET 可以多次使用，上面就是一个例子，获取新的对应值的时候，将原始的内容也进行了获取。&lt;/p&gt;

&lt;p&gt;也可以根据自己的内容排序，之后获取对应PATTERN值得列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; sort l alpha
1) &quot;a&quot;
2) &quot;e&quot;
3) &quot;f&quot;
4) &quot;g&quot;
5) &quot;s&quot;
127.0.0.1:6379&amp;gt; sort l alpha get name*
1) &quot;xiaoh&quot;
2) &quot;me&quot;
3) &quot;huo&quot;
4) &quot;blog&quot;
5) &quot;xingming&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的GET还可以获取对象中的一个字段的值（hash可以作为对象来使用）使用特殊字符&lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; lpush l 5 3 4 2 1
(integer) 5
127.0.0.1:6379&amp;gt; hset user1 name this
(integer) 1
127.0.0.1:6379&amp;gt; hset user4 name xiaoh
(integer) 1
127.0.0.1:6379&amp;gt; hset user2 name blog
(integer) 1
127.0.0.1:6379&amp;gt; hset user5 name me
(integer) 1
127.0.0.1:6379&amp;gt; hset user3 name from
(integer) 1
127.0.0.1:6379&amp;gt; sort l get user*-&amp;gt;name
1) &quot;this&quot;
2) &quot;blog&quot;
3) &quot;from&quot;
4) &quot;xiaoh&quot;
5) &quot;me&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果对应的hash对象不存在，会返回&lt;code class=&quot;highlighter-rouge&quot;&gt;(nil)&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;limit-start-count&quot;&gt;[LIMIT start count]&lt;/h5&gt;

&lt;p&gt;默认排序结果全部显示，可以使用LIMIT来限制显示的数量，下标start默认从0开始&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; sort l limit 2 3
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;5&quot;
127.0.0.1:6379&amp;gt;

127.0.0.1:6379&amp;gt; sort l get user*-&amp;gt;name limit 1 3
1) &quot;blog&quot;
2) &quot;from&quot;
3) &quot;xiaoh&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;store-dstkey&quot;&gt;[STORE dstkey]&lt;/h5&gt;

&lt;p&gt;如果对集合经常按照固定的模式去排序，那么把排序结果缓存起来会减少不少&lt;code class=&quot;highlighter-rouge&quot;&gt;cpu&lt;/code&gt;开销.使用&lt;code class=&quot;highlighter-rouge&quot;&gt;store&lt;/code&gt;选项可以将排序内容保存到指定&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;中。保存的类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; sort l get user*-&amp;gt;name limit 1 3 store dst
(integer) 3
127.0.0.1:6379&amp;gt; lrange dst 0 -1
1) &quot;blog&quot;
2) &quot;from&quot;
3) &quot;xiaoh&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;功能介绍完后，再讨论下关于排序的一些问题。如果我们有多个&lt;code class=&quot;highlighter-rouge&quot;&gt;redis server&lt;/code&gt;的话，不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;可能存在于不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;上。比如name1 name2 name3 name4 name5，很有可能分别在多个不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;上存贮着。这种情况会对排序性能造成很大的影响。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;作者在他的&lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt;上提到了这个问题的解决办法，就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;key tag&lt;/code&gt;将需要排序的&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;都放到同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;上 。&lt;/p&gt;

&lt;p&gt;由于具体决定哪个&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;存在哪个服务器上一般都是在&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;端&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;的办法来做的。我们可以通过只对&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的部分进行&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;举个例子假如我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;如果发现&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;中包含&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;。那么只对&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;包含的内容进行&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;。我们将四个&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;，都这样命名&lt;code class=&quot;highlighter-rouge&quot;&gt;[name]1 [name]2 [name]3 [name]4 [name]5&lt;/code&gt;，于是&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;程序就会把他们都放到同一&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;还有一个问题也比较严重。如果要&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;的集合非常大的话排序就会消耗很长时间。由于&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;单线程的，所以长时间的排序操作会阻塞其他&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;的请求。解决办法是通过主从复制机制将数据复制到多个&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;上。然后我们只在&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;上做排序操作。并进可能的对排序结果缓存。另外就是一个方案是就是采用&lt;code class=&quot;highlighter-rouge&quot;&gt;sorted set&lt;/code&gt;对需要按某个顺序访问的集合建立索引。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;transaction&quot;&gt;&lt;a href=&quot;#transaction&quot;&gt;事物&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;对事务的支持目前还比较简单。&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;只能保证一个&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;发起的事务中的命令可以连续的执行，而中间不会插入其他&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;的命令。由于&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;是单线程来处理所有&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;的请求的所以做到这点是很容易的。&lt;/p&gt;

&lt;h5 id=&quot;multi&quot;&gt;multi&lt;/h5&gt;

&lt;p&gt;一般情况下&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;在接受到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;发来的命令后会立即处理并返回处理结果，但是当一个&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;在一个连接中发出&lt;code class=&quot;highlighter-rouge&quot;&gt;multi&lt;/code&gt;命令，这个连接会进入一个事务上下文，该连接后续的命令并不是立即执行，而是先放到一个队列中。当从此连接受到&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;命令后，&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到一起返回给&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;.然后此连接就结束事务上下文.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; multi
OK
127.0.0.1:6379&amp;gt; incr a
QUEUED
127.0.0.1:6379&amp;gt; incr a
QUEUED
127.0.0.1:6379&amp;gt; incr b
QUEUED
127.0.0.1:6379&amp;gt; exec
1) (integer) 1
2) (integer) 2
3) (integer) 1
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例子中已经说明，当执行&lt;code class=&quot;highlighter-rouge&quot;&gt;incr a&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;incr b&lt;/code&gt; 的时候，是放到了队列里面，当&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;时，执行了队列中的命令。&lt;/p&gt;

&lt;p&gt;当事物写到一半，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;discard&lt;/code&gt;来取消事物&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; multi
OK
127.0.0.1:6379&amp;gt; incr a
QUEUED
127.0.0.1:6379&amp;gt; incr b
QUEUED
127.0.0.1:6379&amp;gt; discard
OK
127.0.0.1:6379&amp;gt; get a
&quot;2&quot;
127.0.0.1:6379&amp;gt; get b
&quot;1&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以发现这次&lt;code class=&quot;highlighter-rouge&quot;&gt;incr a&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;incr b&lt;/code&gt;都没被执行。&lt;code class=&quot;highlighter-rouge&quot;&gt;discard&lt;/code&gt;命令其实就是清空事务的命令队列并退出事务上下文&lt;/p&gt;

&lt;h5 id=&quot;watch&quot;&gt;watch&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Watch&lt;/code&gt; 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; watch a
OK
127.0.0.1:6379&amp;gt; get a
&quot;5&quot;
127.0.0.1:6379&amp;gt; set a 6
OK
127.0.0.1:6379&amp;gt; incr a
(integer) 7
127.0.0.1:6379&amp;gt; get a
&quot;7&quot;
127.0.0.1:6379&amp;gt; multi
OK
127.0.0.1:6379&amp;gt; set a 2
QUEUED
127.0.0.1:6379&amp;gt; exec
(nil)
127.0.0.1:6379&amp;gt; get a
&quot;7&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;discard&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;unwatch&lt;/code&gt; 会清除 &lt;code class=&quot;highlighter-rouge&quot;&gt;watch&lt;/code&gt; 的监听&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;缺点&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的事务实现是如此简单，当然会存在一些问题。第一个问题是&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;只能保证事务的每个命令连续执行，但是如果事务中的一个命令失败了，并不回滚其他命令，比如使用的命令类型不匹配。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; set b 1
OK
127.0.0.1:6379&amp;gt; set a e
OK
127.0.0.1:6379&amp;gt; multi
OK
127.0.0.1:6379&amp;gt; incr a
QUEUED
127.0.0.1:6379&amp;gt; incr b
QUEUED
127.0.0.1:6379&amp;gt; exec
1) (error) ERR value is not an integer or out of range
2) (integer) 2
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以发现，虽然执行中间有问题，但并没有回滚，其他命令还是执行了。&lt;/p&gt;

&lt;p&gt;最后一个十分罕见的问题是，当事务的执行过程中，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;意外的挂了。很遗憾只有部分命令执行了，后面的也就被丢弃了。当然如果我们使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;append-only file&lt;/code&gt;方式持久化，&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;会用单个&lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt;操作写入整个事务内容。即是是这种方式还是有可能只部分写入了事务到磁盘。发生部分写入事务的情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;重启时会检测到这种情况，然后失败退出。可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-check-aof&lt;/code&gt;工具进行修复，修复会删除部分写入的事务内容。修复完后就能够重新启动了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pipeline&quot;&gt;&lt;a href=&quot;#pipeline&quot;&gt;管道&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;cs&lt;/code&gt;模式的&lt;code class=&quot;highlighter-rouge&quot;&gt;tcp server&lt;/code&gt;，使用和&lt;code class=&quot;highlighter-rouge&quot;&gt;http&lt;/code&gt;类似的请求响应协议。&lt;/p&gt;

&lt;p&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;可以通过一个&lt;code class=&quot;highlighter-rouge&quot;&gt;socket&lt;/code&gt;连接发起多个请求命令。每个请求命令发出后&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;通常会阻塞并等待&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;服务处理，&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;处理完后请求命令后会将结果通过响应报文返回给&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;。基本的通信过程如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Client: INCR X
Server: 1
Client: INCR X
Server: 2
Client: INCR X
Server: 3
Client: INCR X
Server: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基本上四个命令需要8个&lt;code class=&quot;highlighter-rouge&quot;&gt;tcp&lt;/code&gt;报文才能完成。由于通信会有网络延迟,假如从&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;之间的包传输时间需要0.125秒。那么上面的四个命令8个报文至少会需要1秒才能完成。这样即使&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;每秒能处理100个命令，而我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;也只能一秒钟发出四个命令。这显示没有充分利用&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的处理能力。除了可以利用&lt;code class=&quot;highlighter-rouge&quot;&gt;mget&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;mset&lt;/code&gt;之类的单条命令处理多个&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的命令外我们还可以利用&lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt;的方式从&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;打包多条命令一起发出，不需要等待单条命令的响应返回，而&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;服务端会处理完多条命令后会将多条命令的处理结果打包到一起返回给客户端。通信过程如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Client: INCR X
Client: INCR X
Client: INCR X
Client: INCR X
Server: 1
Server: 2
Server: 3
Server: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假设不会因为&lt;code class=&quot;highlighter-rouge&quot;&gt;tcp&lt;/code&gt;报文过长而被拆分。可能两个&lt;code class=&quot;highlighter-rouge&quot;&gt;tcp&lt;/code&gt;报文就能完成四条命令,&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;可以将四个&lt;code class=&quot;highlighter-rouge&quot;&gt;incr&lt;/code&gt;命令放到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;tcp&lt;/code&gt;报文一起发送，&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;则可以将四条命令的处理结果放到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;tcp&lt;/code&gt;报文返回。&lt;/p&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt;方式当有大批量的操作时候。我们可以节省很多原来浪费在网络延迟的时间。需要注意到是用&lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt;方式打包命令发送，&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;必须在处理完所有命令前先缓存起所有命令的处理结果。打包的命令越多，缓存消耗内存也越多。所以并是不是打包的命令越多越好。具体多少合适需要根据具体情况测试。&lt;/p&gt;

&lt;p&gt;下面是我测试是否使用pipeline的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from redis import Redis
import time

r = Redis()

def without_pipeline(times=100000):
    r.set(&#39;a&#39;, 0)
    for i in range(times):
        r.incr(&#39;a&#39;)

def use_pipeline(times=100000):
    r.set(&#39;a&#39;, 0)
    r.set(&#39;a&#39;, 0)
    pip = r.pipeline()
    for i in range(times):
        pip.incr(&#39;a&#39;)
    pip.execute()

start = time.time()
without_pipeline()
end = time.time()
print &#39;without pipeline spendtime:%f&#39; % (end-start)

start = time.time()
use_pipeline()
end = time.time()
print &#39;use pipeline spendtime:%f&#39; % (end-start)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;without pipeline spendtime:4.221240
use pipeline spendtime:1.572646
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看起来对效果提升还是很明显的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;subpub&quot;&gt;&lt;a href=&quot;#subpub&quot;&gt;发布/订阅&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;发布订阅(&lt;code class=&quot;highlighter-rouge&quot;&gt;pub/sub&lt;/code&gt;)是一种消息通信模式，主要的目的是解耦消息发布者和消息订阅者之间的耦合，这点和设计模式中的观察者模式比较相似。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pub/sub&lt;/code&gt;不仅仅解决发布者和订阅者直接代码级别耦合也解决两者在物理部署上的耦合。&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;作为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;pub/sub server&lt;/code&gt;，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;subscribe&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;psubscribe&lt;/code&gt;命令向&lt;code class=&quot;highlighter-rouge&quot;&gt;redis server&lt;/code&gt;订阅自己感兴趣的消息类型，&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;将消息类型称为通道(&lt;code class=&quot;highlighter-rouge&quot;&gt;channel&lt;/code&gt;)。当发布者通过&lt;code class=&quot;highlighter-rouge&quot;&gt;publish&lt;/code&gt;命令向&lt;code class=&quot;highlighter-rouge&quot;&gt;redis server&lt;/code&gt;发送特定类型的消息时。订阅该消息类型的全部&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;都会收到此消息。这里消息的传递是多对多的。一个&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;可以订阅多个&lt;code class=&quot;highlighter-rouge&quot;&gt;channel&lt;/code&gt;,也可以向多个&lt;code class=&quot;highlighter-rouge&quot;&gt;channel&lt;/code&gt;发送消息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pub/Sub&lt;/code&gt;功能（&lt;code class=&quot;highlighter-rouge&quot;&gt;means Publish&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Subscribe&lt;/code&gt;）即发布及订阅功能。基于事件的系统中，&lt;code class=&quot;highlighter-rouge&quot;&gt;Pub/Sub&lt;/code&gt;是目前广泛使用的通信模型，它采用事件作为基本的通信机制，提供大规模系统所要求的松散耦合的交互模式：订阅者(如客户端)以事件订阅的方式表达出它有兴趣接收的一个事件或一类事件；发布者(如服务器)可将订阅者感兴趣的事件随时通知相关订阅者。&lt;/p&gt;

&lt;p&gt;Pub/Sub是可适用于可扩展要求高、松散耦合系统的分布式交互模型&lt;/p&gt;

&lt;p&gt;在抽象层中，它的时间非耦合、空间非耦合和同步非耦合性可允许参与者不依赖另一个而独立操作，具有一定的可扩展性；然而在实现层，可扩展性仍受其他原因的牵制。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;灵活的订阅要求复杂的过滤和路由算法&lt;/li&gt;
  &lt;li&gt;高可用性开销（事件侦听、日志重传）；&lt;/li&gt;
  &lt;li&gt;消息认可带来的网络流量消耗；&lt;/li&gt;
  &lt;li&gt;庞大的订阅者数据带来的系统开销；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于事件的Pub/Sub中间件的开发与利用在一定程度上可以提高系统的效率。&lt;/p&gt;

&lt;p&gt;以下是我的测试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# code
import time, redis

r = redis.StrictRedis()
p = r.pubsub()
channel = &#39;channel&#39;

def handler(message):
    print &#39;Receive msg:%s&#39; % message[&#39;data&#39;]

p.subscribe(**{channel:handler})

thread = p.run_in_thread(sleep_time=0.01)

time.sleep(60)
thread.stop()

# running script
python pubsub.py

# ipython
In [2]: import redis
In [3]: r = redis.StrictRedis()
In [5]: r.publish(&#39;channel&#39;, &#39;xiaoh.me&#39;)
Out[5]: 1L
In [6]: r.publish(&#39;channel&#39;, &#39;my name is xiaoh&#39;)
Out[6]: 1L

# script output
Receive msg:xiaoh.me
Receive msg:my name is xiaoh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上进行了简单的测试。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;persistence&quot;&gt;&lt;a href=&quot;#persistence&quot;&gt;持久化&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Redis&lt;/code&gt;是一个支持持久化的内存数据库，也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;需要经常将内存中的数据同步到磁盘来保证持久化。&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;支持两种持久化方式，一种是&lt;code class=&quot;highlighter-rouge&quot;&gt;Snapshotting&lt;/code&gt;（快照）也是默认方式，另一种是&lt;code class=&quot;highlighter-rouge&quot;&gt;Append-only file&lt;/code&gt;（缩写aof）的方式。下面分别介绍&lt;/p&gt;

&lt;h5 id=&quot;snapshotting&quot;&gt;Snapshotting&lt;/h5&gt;

&lt;p&gt;快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为&lt;code class=&quot;highlighter-rouge&quot;&gt;dump.rdb&lt;/code&gt;。可以通过配置设置自动做快照持久化的方式。我们可以配置&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;在n秒内如果超过m个key被修改就自动做快照，下面是默认的快照保存配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;save 900 1  #900秒内如果超过1个key被修改，则发起快照保存
save 300 10 #300秒内容如超过10个key被修改，则发起快照保存
save 60 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面介绍详细的快照保存过程&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;,现在有了子进程和父进程。&lt;/li&gt;
  &lt;li&gt;父进程继续处理&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;请求，子进程负责将内存内容写入到临时文件。由于os的写时复制机制（&lt;code class=&quot;highlighter-rouge&quot;&gt;copy on write&lt;/code&gt;)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数据是&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;时刻整个数据库的一个快照。&lt;/li&gt;
  &lt;li&gt;当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;save&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;bgsave&lt;/code&gt;命令通知&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;做一次快照持久化。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save&lt;/code&gt;操作是在主线程中保存快照的，由于&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;是用一个主线程来处理所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;的请求，这种方式会阻塞所有&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;请求。所以不推荐使用。另一点需要注意的是，每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步脏数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，可能会严重影响性能。&lt;/p&gt;

&lt;p&gt;另外由于快照方式是在一定间隔时间做一次的，所以如果&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;意外&lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt;掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用&lt;code class=&quot;highlighter-rouge&quot;&gt;aof&lt;/code&gt;持久化方式。&lt;/p&gt;

&lt;h5 id=&quot;append-only-file&quot;&gt;Append-only file&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;aof&lt;/code&gt;比快照方式有更好的持久化性，是由于在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;aof&lt;/code&gt;持久化方式时,&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;会将每一个收到的写命令都通过&lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt;函数追加到文件中(默认是 &lt;code class=&quot;highlighter-rouge&quot;&gt;appendonly.aof&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于os会在内核中缓存&lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt;做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;我们想要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;fsync&lt;/code&gt;函数强制os写入到磁盘的时机。有三种方式如下（默认是：每秒fsync一次）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;appendonly yes           //启用aof持久化方式&lt;/li&gt;
  &lt;li&gt;appendfsync always       //每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用&lt;/li&gt;
  &lt;li&gt;appendfsync everysec     //每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐&lt;/li&gt;
  &lt;li&gt;appendfsync no           //完全依赖os，性能最好,持久化没保证&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;aof&lt;/code&gt;的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用&lt;code class=&quot;highlighter-rouge&quot;&gt;incr test&lt;/code&gt;命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条&lt;code class=&quot;highlighter-rouge&quot;&gt;set test 100&lt;/code&gt;就够了。为了压缩aof的持久化文件。&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;bgrewriteaof&lt;/code&gt;命令。收到此命令&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。具体过程如下&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt; ，现在有父子两个进程&lt;/li&gt;
  &lt;li&gt;子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令&lt;/li&gt;
  &lt;li&gt;父进程继续处理&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;请求，除了把写命令写入到原来的&lt;code class=&quot;highlighter-rouge&quot;&gt;aof&lt;/code&gt;文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。&lt;/li&gt;
  &lt;li&gt;当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。&lt;/li&gt;
  &lt;li&gt;现在父进程可以使用临时文件替换老的&lt;code class=&quot;highlighter-rouge&quot;&gt;aof&lt;/code&gt;文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意到是重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,这点和快照有点类似。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;master-slave&quot;&gt;&lt;a href=&quot;#master-slave&quot;&gt;主从复制&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Redis&lt;/code&gt;主从复制配置和使用都非常简单。通过主从复制可以允许多个&lt;code class=&quot;highlighter-rouge&quot;&gt;slave server&lt;/code&gt;拥有和&lt;code class=&quot;highlighter-rouge&quot;&gt;master server&lt;/code&gt;相同的数据库副本。&lt;/p&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;主从复制的一些特点&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;可以有多个&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;除了多个&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;连到相同的&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;外，&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;也可以连接其他&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;形成图状结构&lt;/li&gt;
  &lt;li&gt;主从复制不会阻塞&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;。也就是说当一个或多个&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;进行初次同步数据时，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;可以继续处理&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;发来的请求。相反&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;在初次同步数据时则会阻塞不能处理client的请求。&lt;/li&gt;
  &lt;li&gt;主从复制可以用来提高系统的可伸缩性,我们可以用多个&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;专门用于&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;的读请求，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;操作可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;来处理。也可以用来做简单的数据冗余&lt;/li&gt;
  &lt;li&gt;可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;禁用数据持久化，只需要注释掉&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;配置文件中的所有&lt;code class=&quot;highlighter-rouge&quot;&gt;save&lt;/code&gt;配置，然后只在&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;上配置数据持久化。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面介绍下主从复制的过程&lt;/p&gt;

&lt;p&gt;当设置好&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;服务器后，&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;会建立和&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;的连接，然后发送&lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;无论是第一次同步建立的连接还是连接断开后的重新连接，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;都会启动一个后台进程，将数据库快照保存到文件中，同时&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;主进程会开始收集新的写命令并缓存起来。后台进程完成写文件后，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;就发送文件给&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;将文件保存到磁盘上，然后加载到内存恢复数据库快照到&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;接着&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;就会把缓存的命令转发给&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;。而且后续&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;收到的写命令都会通过开始建立的连接发送给&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;的同步数据的命令和从&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;发送的命令使用相同的协议格式。当&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;的连接断开时&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;可以自动重新建立连接。&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;同时收到多个&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;发来的同步连接命令，只会使用启动一个进程来写数据库镜像，然后发送给所有&lt;code class=&quot;highlighter-rouge&quot;&gt;slave&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;配置slave服务器很简单，只需要在配置文件中加入如下配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;slaveof 192.168.1.1 6379  #指定master的ip和端口
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;swapmemory&quot;&gt;&lt;a href=&quot;#swapmemory&quot;&gt;虚拟内存&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;首先说明下&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的虚拟内存与&lt;code class=&quot;highlighter-rouge&quot;&gt;os&lt;/code&gt;的虚拟内存不是一码事，但是思路和目的都是相同的。就是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出宝贵的内存空间用于其他需要访问的数据。尤其是对于&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;这样的内存数据库，内存总是不够用的。除了可以将数据分割到多个&lt;code class=&quot;highlighter-rouge&quot;&gt;redis server&lt;/code&gt;外。另外的能够提高数据库容量的办法就是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;vm&lt;/code&gt;把那些不经常访问的数据交换的磁盘上。&lt;/p&gt;

&lt;p&gt;如果我们的存储的数据总是有少部分数据被经常访问，大部分数据很少被访问，对于网站来说确实总是只有少量用户经常活跃。当少量数据被经常访问时，使用vm不但能提高单台&lt;code class=&quot;highlighter-rouge&quot;&gt;redis server&lt;/code&gt;数据库的容量，而且也不会对性能造成太多影响。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;没有使用&lt;code class=&quot;highlighter-rouge&quot;&gt;os&lt;/code&gt;提供的虚拟内存机制而是自己在用户态实现了自己的虚拟内存机制,作者在自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt;专门解释了其中原因。&lt;a href=&quot;http://antirez.com/post/redis-virtual-memory-story.html&quot;&gt;http://antirez.com/post/redis-virtual-memory-story.html&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;主要的理由有两点&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;os&lt;/code&gt;的虚拟内存是已4k页面为最小单位进行交换的。而&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的大多数对象都远小于4k，所以一个os页面上可能有多个&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;对象。另外&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的集合对象类型如&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;可能存在与多个os页面上。最终可能造成只有10%key被经常访问，但是所有&lt;code class=&quot;highlighter-rouge&quot;&gt;os&lt;/code&gt;页面都会被&lt;code class=&quot;highlighter-rouge&quot;&gt;os&lt;/code&gt;认为是活跃的，这样只有内存真正耗尽时os才会交换页面。&lt;/li&gt;
  &lt;li&gt;相比于os的交换方式。&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;可以将被交换到磁盘的对象进行压缩,保存到磁盘的对象可以去除指针和对象元数据信息。一般压缩后的对象会比内存中的对象小10倍。这样&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的vm会比os vm能少做很多io操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;vm&quot;&gt;下面是vm相关配置&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;vm-enabled yes                    #开启vm功能&lt;/li&gt;
  &lt;li&gt;vm-swap-file /tmp/redis.swap      #交换出来的value保存的文件路径/tmp/redis.swap&lt;/li&gt;
  &lt;li&gt;vm-max-memory 1000000             #redis使用的最大内存上限，超过上限后redis开始交换value到磁盘文件中。&lt;/li&gt;
  &lt;li&gt;vm-page-size 32                   #每个页面的大小32个字节&lt;/li&gt;
  &lt;li&gt;vm-pages 134217728                #最多使用在文件中使用多少页面,交换文件的大小 = vm-page-size * vm-pages&lt;/li&gt;
  &lt;li&gt;vm-max-threads 4                  #用于执行value对象换入换出的工作线程数量。0表示不使用工作线程（后面介绍)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;vm&lt;/code&gt;在设计上为了保证&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的查找速度，只会将&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;交换到&lt;code class=&quot;highlighter-rouge&quot;&gt;swap&lt;/code&gt;文件中。所以如果是内存问题是由于太多&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;很小的&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;造成的，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;vm&lt;/code&gt;并不能解决。&lt;/p&gt;

&lt;p&gt;和os一样&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;也是按页面来交换对象的。&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;规定同一个页面只能保存一个对象。但是一个对象可以保存在多个页面中。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;使用的内存没超过&lt;code class=&quot;highlighter-rouge&quot;&gt;vm-max-memory&lt;/code&gt;之前是不会交换任何&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;的。当超过最大内存限制后，&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;会选择较老的对象。如果两个对象一样老会优先交换比较大的对象，精确的公式&lt;code class=&quot;highlighter-rouge&quot;&gt;swappability = age*log(size_in_memory)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;vm-page-size&lt;/code&gt;的设置应该根据自己的应用将页面的大小设置为可以容纳大多数对象的大小。太大了会浪费磁盘空间，太小了会造成交换文件出现碎片。&lt;/p&gt;

&lt;p&gt;对于交换文件中的每个页面，&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;会在内存中对应一个&lt;code class=&quot;highlighter-rouge&quot;&gt;1bit&lt;/code&gt;值来记录页面的空闲状态。所以像上面配置中页面数量(&lt;code class=&quot;highlighter-rouge&quot;&gt;vm-pages 134217728&lt;/code&gt;)会占用16M内存用来记录页面空闲状态。`&lt;/p&gt;

&lt;p&gt;vm-max-threads&lt;code class=&quot;highlighter-rouge&quot;&gt;表示用做交换任务的线程数量。如果大于0推荐设为服务器的&lt;/code&gt;cpu core`的数量。如果是0则交换过程在主线程进行。&lt;/p&gt;

&lt;h5 id=&quot;vm-1&quot;&gt;参数配置讨论完后，在来简单介绍下vm是如何工作的，&lt;/h5&gt;

&lt;h6 id=&quot;vm-max-threads0blocking-vm&quot;&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;vm-max-threads&lt;/code&gt;设为0时(&lt;code class=&quot;highlighter-rouge&quot;&gt;Blocking VM&lt;/code&gt;)&lt;/h6&gt;

&lt;p&gt;** 换出 **&lt;/p&gt;

&lt;p&gt;主线程定期检查发现内存超出最大上限后，会直接已阻塞的方式,将选中的对象保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;swap&lt;/code&gt;文件中，并释放对象占用的内存,此过程会一直重复直到下面条件满足&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;内存使用降到最大限制以下&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;swap&lt;/code&gt;文件满了&lt;/li&gt;
  &lt;li&gt;几乎全部的对象都被交换到磁盘了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;** 换入 **&lt;/p&gt;

&lt;p&gt;当有&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;请求&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;被换出的&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;时。主线程会以阻塞的方式从文件中加载对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;对象，加载时此时会阻塞所以&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;。然后处理&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;的请求&lt;/p&gt;

&lt;h6 id=&quot;vm-max-threads0threaded-vm&quot;&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;vm-max-threads&lt;/code&gt;大于0(&lt;code class=&quot;highlighter-rouge&quot;&gt;Threaded VM&lt;/code&gt;)&lt;/h6&gt;

&lt;p&gt;** 换出 **&lt;/p&gt;

&lt;p&gt;当主线程检测到使用内存超过最大上限，会将选中的要交换的对象信息放到一个队列中交由工作线程后台处理，主线程会继续处理&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;请求。&lt;/p&gt;

&lt;p&gt;** 换入 **&lt;/p&gt;

&lt;p&gt;如果有&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;请求的&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;被换出了，主线程先阻塞发出命令的&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;,然后将加载对象的信息放到一个队列中，让工作线程去加载。加载完毕后工作线程通知主线程。主线程再执行&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;的命令。这种方式只阻塞请求&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;被换出&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;总的来说&lt;code class=&quot;highlighter-rouge&quot;&gt;blocking vm&lt;/code&gt;的方式总的性能会好一些，因为不需要线程同步，创建线程和恢复被阻塞的&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;等开销。但是也相应的牺牲了响应性。&lt;code class=&quot;highlighter-rouge&quot;&gt;threaded vm&lt;/code&gt;的方式主线程不会阻塞在磁盘io上，所以响应性更好。&lt;/p&gt;

&lt;p&gt;如果我们的应用不太经常发生换入换出，而且也不太在意有点延迟的话则推荐使用&lt;code class=&quot;highlighter-rouge&quot;&gt;blocking vm&lt;/code&gt;的方式。&lt;/p&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;redis vm&lt;/code&gt;的更详细介绍可以参考下面链接&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://antirez.com/post/redis-virtual-memory-story.html&quot;&gt;http://antirez.com/post/redis-virtual-memory-story.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://redis.io/topics/internals-vm&quot;&gt;http://redis.io/topics/internals-vm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;documents&quot;&gt;&lt;a href=&quot;#documents&quot;&gt;文档&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://redisdoc.com/index.html&quot;&gt;http://redisdoc.com/index.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/andymccurdy/redis-py&quot;&gt;https://github.com/andymccurdy/redis-py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;

</description>
        <pubDate>Thu, 30 Jun 2016 13:43:38 +0800</pubDate>
        <link>http://www.xiaoh.me/2016/06/30/redis-advanced/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2016/06/30/redis-advanced/</guid>
        
        <category>数据库</category>
        
        <category>Redis</category>
        
        
      </item>
    
      <item>
        <title>简单的弹幕聊天系统构建</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;今天了一个简单的弹幕聊天的DEMO，后台是Tornado+Websocket，项目地址:&lt;a href=&quot;https://github.com/pmars/barchat&quot;&gt;https://github.com/pmars/barchat&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;如果你只想看看代码，知道这个是怎么做的，那么直接去github上面看代码即可，下面只是设计到了一些理论知识而已。&lt;/p&gt;

&lt;p&gt;聊到这个弹幕聊天的工具，必须解释一下WebSocket和http的对比。&lt;/p&gt;

&lt;h5 id=&quot;websockethtml5httphttp&quot;&gt;WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）&lt;/h5&gt;

&lt;p&gt;首先HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/post-bar-chat.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有交集，但是并不是全部。&lt;/p&gt;

&lt;p&gt;另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。。&lt;/p&gt;

&lt;h5 id=&quot;websocket&quot;&gt;Websocket是什么样的协议，具体有什么优点&lt;/h5&gt;

&lt;p&gt;传统的HTTP协议虽然用的比较广泛（事实上互联网的绝大多数请求都是HTTP协议的），但还是有一定的不足：&lt;/p&gt;

&lt;p&gt;1) HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。&lt;/p&gt;

&lt;p&gt;在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request = Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。&lt;/p&gt;

&lt;p&gt;首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。&lt;/p&gt;

&lt;p&gt;在握手阶段是一样的(from wikipedia)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这段类似HTTP协议的握手请求中，多了几个东西&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Upgrade: websocket
Connection: Upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个就是Websocket的核心了，告诉Apache、Nginx等服务器：* 发起的是Websocket协议*&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先，&lt;code class=&quot;highlighter-rouge&quot;&gt;Sec-WebSocket-Key&lt;/code&gt; 是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Base64 encode&lt;/code&gt;的值，这个是浏览器随机生成的，告诉服务器验证是不是真的是Websocket助理&lt;/p&gt;

&lt;p&gt;然后，&lt;code class=&quot;highlighter-rouge&quot;&gt;Sec_WebSocket-Protocol&lt;/code&gt; 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。&lt;/p&gt;

&lt;p&gt;最后，&lt;code class=&quot;highlighter-rouge&quot;&gt;Sec-WebSocket-Version&lt;/code&gt; 是告诉服务器所使用的Websocket Draft（协议版本）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用的一个东西~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Upgrade: websocket
Connection: Upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;依然是固定的，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。&lt;/p&gt;

&lt;p&gt;然后，&lt;code class=&quot;highlighter-rouge&quot;&gt;Sec-WebSocket-Accept&lt;/code&gt; 这个则是经过服务器确认，并且加密过后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sec-WebSocket-Key&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;后面的，&lt;code class=&quot;highlighter-rouge&quot;&gt;Sec-WebSocket-Protocol&lt;/code&gt; 则是表示最终使用的协议。&lt;/p&gt;

&lt;p&gt;至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。&lt;/p&gt;

&lt;h5 id=&quot;websocket-1&quot;&gt;Websocket的作用&lt;/h5&gt;

&lt;p&gt;在使用Websocket之前呢，客户端想从服务器监测信息的变化，主要使用两种方式，1,Ajex轮询，2,Long Poll&lt;/p&gt;

&lt;p&gt;Ajax轮询主要就是隔一段时间客户端去访问一下服务器，看看是否有数据更新，这样处理有信息不及时，带宽压力大，服务器压力大等问题&lt;/p&gt;

&lt;p&gt;Long Poll 采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始&lt;/p&gt;

&lt;p&gt;这两种方式都是因为HTTP协议的一个特点：&lt;em&gt;被动性&lt;/em&gt;,就是说，服务器没有办法直接发送信息给客户端。&lt;/p&gt;

&lt;p&gt;而Websocket的出现就解决了这个问题，他可以持久连接，并且可以双向发送信息。&lt;/p&gt;

&lt;p&gt;Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求。&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;以上就是WebSocket相对与HTTP的不同之处&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;section&quot;&gt;弹幕系统&lt;/h5&gt;

&lt;p&gt;理解了上面的WebSocket的功能，弹幕系统就很容易理解了，在服务器和客户端建立一个WebSocket连接，这样用户A发送弹幕会通过WebSocket发送给服务器，服务器在通过WebSocket的链接发送给所有连接在服务器上的用户。&lt;/p&gt;

&lt;p&gt;代码详见 &lt;a href=&quot;https://github.com/pmars/barchat&quot;&gt;https://github.com/pmars/barchat&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;弹幕聊天页面 &lt;a href=&quot;http://chat.xiaoh.me&quot;&gt;http://chat.xiaoh.me&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;

</description>
        <pubDate>Thu, 16 Jun 2016 21:24:36 +0800</pubDate>
        <link>http://www.xiaoh.me/2016/06/16/barrage-chat/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2016/06/16/barrage-chat/</guid>
        
        <category>tornado</category>
        
        <category>python</category>
        
        <category>websocket</category>
        
        
      </item>
    
      <item>
        <title>记几件有趣的事</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在这里记下一些孩子有趣或者有触动的故事，留给自己日后回味&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section&quot;&gt;日期：三四个月大&lt;/h4&gt;

&lt;p&gt;具体时间已经忘记了，这个只是回忆，有一天上班回家，妈抱着孩子和刚进屋子的我们说的。&lt;/p&gt;

&lt;p&gt;妈哄着孩子经常不放纸尿裤这类东西，只是屁股下面点一层布头，这天小嘉瑞在他奶奶腿上的时候拉屎了，妈就给他屁股抬起来了，弄屁股上的屎去了，几秒钟之后回头看嘉瑞的脸上竟然有水珠，哈哈哈哈，他尿了，由于屁股抬高了，直接尿到了自己脸上。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-1&quot;&gt;日期：2016年 06月 10日 星期五&lt;/h4&gt;

&lt;p&gt;gary已经五个月20天了。&lt;/p&gt;

&lt;p&gt;第一次生病，发烧了，不算严重，37.8左右的样子，开始的时候并没有感觉，和往常一样，睡着觉会不自觉的哭起来，也就是两个来回就可以完事的，可这次并没有，我出来给他弄点水喝，媳妇抱着gary，他一直哭着，我觉得不太对，给水弄好了就赶快回卧室看他们俩，这个时候，媳妇也跟着哭起来了，是啊，gary第一次哭的这么久，第一次生病，媳妇也是第一次这么心疼。&lt;/p&gt;

&lt;p&gt;好可爱。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-2&quot;&gt;日期：2016年 06月 16日 星期四&lt;/h4&gt;

&lt;p&gt;嘉瑞一般和我比较亲，没事的时候我朝他一乐他就会高兴一会，也爱看我，哈哈哈&lt;/p&gt;

&lt;p&gt;这天媳妇在床上看着熟睡的嘉瑞，我跑过去聊骚了一下，说：“孩子我可不管，这个世界上我只在乎你”，然而出于懒的抱孩子的心理，我又补了一句（其实也是事实，让我哭一会）：“我你是不管了，你只照顾孩子就可以了”，这个时候媳妇说：“恩，孩子可不管我，他只在乎你”，哈哈哈，瞬间家里这三角恋的关系明朗了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-3&quot;&gt;日期：2016年 06月 16日 至 2016年 09月 05日&lt;/h4&gt;

&lt;p&gt;这段作为中间的补充吧，填补一下空缺。&lt;/p&gt;

&lt;p&gt;中间好多另我们惊喜的地方，第一次坐起来，第一次倒着爬，第一次匍匐前进，第一次单腿前撑，第一次真正的往前爬，都另一个父母激动不已。&lt;/p&gt;

&lt;p&gt;嘉瑞在这段时间都是爷爷奶奶在照顾，爷爷主要抱着他，他特别喜欢在爷爷的肩膀上趴着，每次爷爷抱他，他都特别开心。&lt;/p&gt;

&lt;p&gt;嘉瑞很喜欢在楼道里面，每次抱着上下楼，他都特别兴奋，哇哇的叫，比较纠结的是，我怕影响邻居，但也特别喜欢看他笑，索性我也不逗他，他乐我也不打扰他，顺其自然吧，也挺对不住邻居的。&lt;/p&gt;

&lt;p&gt;嘉瑞学会了嘟着嘴，眼睛一眯，开心的对你笑了，每次奶奶都叫，丑一个，他有的时候领会了，就对着你这么笑。有的时候特别喜欢你的时候，就对着你这么笑，特别可爱。&lt;/p&gt;

&lt;p&gt;补充到这里吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-4&quot;&gt;日期：2016年 09月 05日 星期一&lt;/h4&gt;

&lt;p&gt;好长时间没有记录一些有意思的事情了，最近比较忙，今天偶尔闲下来陪孩子玩，他特别高兴。&lt;/p&gt;

&lt;p&gt;最近给客厅里面全部铺满了爬行垫子，娃娃的活动范围又扩大了，今天晚上回家他们正在客厅玩，gary一看我进来了，激动的不的了，从阳台那边直接往我这边怕过来了，大约四五米的距离，爬的很快，哈哈哈哈。&lt;/p&gt;

&lt;p&gt;期间媳妇一直在抱怨，就喜欢爸爸，跟你爸爸这么亲呢，瞧给你乐的…哈哈，这小心眼的脾气用在了在孩子面前挣宠上啦。&lt;/p&gt;

&lt;p&gt;最近嘉瑞学了很多新招式，就在那边坐着，举着两只胳膊上下摇晃，嘴里还有节奏的，喔喔喔喔喔，之后俯身趴下，身体还波浪似的，摇着，喔喔喔喔喔….哈哈哈，我逗他就嘴里喊着，喔喔喔喔喔，他就在那边做一遍，都坏我了！&lt;/p&gt;

&lt;p&gt;我在那边拿着他的布球，里面有铃铛的那种，仍一下还有声音，在客厅当足球踢，之后嘉瑞就在我脚下面追着球跑，我在那边过人，他摇着圈追我，哈哈！&lt;/p&gt;

&lt;p&gt;可能是我好久没有这么陪他了，今天他特别兴奋，平常九点钟基本上就跑去睡觉了，今天玩到了大约十点多，看着他今天这么开心，以后真得好好陪陪孩子。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;

</description>
        <pubDate>Sat, 11 Jun 2016 08:13:47 +0800</pubDate>
        <link>http://www.xiaoh.me/2016/06/11/son-things/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2016/06/11/son-things/</guid>
        
        <category>杂谈</category>
        
        
      </item>
    
      <item>
        <title>Python Set(集合)类型操作总结</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;sets 支持 x in set, len(set),和 for x in set。作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;下面来点简单的小例子说明:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = set(&#39;spam&#39;)
&amp;gt;&amp;gt;&amp;gt; y = set([&#39;h&#39;,&#39;a&#39;,&#39;m&#39;])
&amp;gt;&amp;gt;&amp;gt; x, y
(set([&#39;a&#39;, &#39;p&#39;, &#39;s&#39;, &#39;m&#39;]), set([&#39;a&#39;, &#39;h&#39;, &#39;m&#39;]))
&amp;gt;&amp;gt;&amp;gt; x &amp;amp; y # 交集
set([&#39;a&#39;, &#39;m&#39;])
&amp;gt;&amp;gt;&amp;gt; x | y # 并集
set([&#39;a&#39;, &#39;p&#39;, &#39;s&#39;, &#39;h&#39;, &#39;m&#39;])
&amp;gt;&amp;gt;&amp;gt; x - y # 差集
set([&#39;p&#39;, &#39;s&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;记得以前个网友提问怎么去除海量列表里重复元素，用hash来解决也行，只不过感觉在性能上不是很高，用set解决还是很不错的，示例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [11,22,33,44,11,22]
&amp;gt;&amp;gt;&amp;gt; b = set(a)
&amp;gt;&amp;gt;&amp;gt; b
set([33, 11, 44, 22])
&amp;gt;&amp;gt;&amp;gt; c = [i for i in b]
&amp;gt;&amp;gt;&amp;gt; c
[33, 11, 44, 22]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;集合用于包含一组无序的对象。要创建集合，可使用set()函数并像下面这样提供一系列的项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s = set([3,5,9,10])      #创建一个数值集合
t = set(&quot;Hello&quot;)         #创建一个唯一字符的集合
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与列表和元组不同，集合是无序的，也无法通过数字进行索引。此外，集合中的元素不能重复。例如，如果检查前面代码中t集合的值，结果会是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t
set([&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;o&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意只出现了一个’l’。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = t | s          # t 和 s的并集
b = t &amp;amp; s          # t 和 s的交集
c = t – s          # 求差集（项在t中，但不在s中）
d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基本操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t.add(&#39;x&#39;)            # 添加一项
s.update([10,37,42])  # 在s中添加多项
t.remove(&#39;H&#39;)         # 使用remove()可以删除一项
len(s)                # set 的长度
x in s                # 测试 x 是否是 s 的成员
x not in s            # 测试 x 是否不是 s 的成员

s.issubset(t)
s &amp;lt;= t                # 测试是否 s 中的每一个元素都在 t 中

s.issuperset(t)
s &amp;gt;= t                # 测试是否 t 中的每一个元素都在 s 中

s.union(t)
s | t                 # 返回一个新的 set 包含 s 和 t 中的每一个元素

s.intersection(t)
s &amp;amp; t                 # 返回一个新的 set 包含 s 和 t 中的公共元素

s.difference(t)
s - t                 # 返回一个新的 set 包含 s 中有但是 t 中没有的元素

s.symmetric_difference(t)
s ^ t                 # 返回一个新的 set 包含 s 和 t 中不重复的元素

s.copy()              #返回 set “s”的一个浅复制
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;请注意：&lt;code class=&quot;highlighter-rouge&quot;&gt;union()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;intersection()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;difference()&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;symmetric_difference()&lt;/code&gt; 的非运算符（&lt;code class=&quot;highlighter-rouge&quot;&gt;non-operator&lt;/code&gt;，就是形如 &lt;code class=&quot;highlighter-rouge&quot;&gt;s.union()&lt;/code&gt;这样的）版本将会接受任何 &lt;code class=&quot;highlighter-rouge&quot;&gt;iterable&lt;/code&gt; 作为参数。相反，它们的运算符版本（&lt;code class=&quot;highlighter-rouge&quot;&gt;operator based counterparts&lt;/code&gt;）要求参数必须是 &lt;code class=&quot;highlighter-rouge&quot;&gt;sets&lt;/code&gt;。这样可以避免潜在的错误，如：为了更可读而使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;set(&#39;abc&#39;) &amp;amp; &#39;cbs&#39;&lt;/code&gt; 来替代 &lt;code class=&quot;highlighter-rouge&quot;&gt;set(&#39;abc&#39;).intersection(&#39;cbs&#39;)&lt;/code&gt;。从 2.3.1 版本中做的更改：以前所有参数都必须是 sets。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，Set 和 ImmutableSet 两者都支持 set 与 set 之间的比较。两个 sets 在也只有在这种情况下是相等的：每一个 set 中的元素都是另一个中的元素（二者互为subset）。一个 set 比另一个 set 小，只有在第一个 set 是第二个 set 的 subset 时（是一个 subset，但是并不相等）。一个 set 比另一个 set 打，只有在第一个 set 是第二个 set 的 superset 时（是一个 superset，但是并不相等）。&lt;/p&gt;

&lt;p&gt;子 set 和相等比较并不产生完整的排序功能。例如：任意两个 sets 都不相等也不互为子 set，因此以下的运算都会返回 False：a&amp;lt;b, a==b, 或者a&amp;gt;b。因此，sets 不提供 &lt;strong&gt;cmp&lt;/strong&gt; 方法。&lt;/p&gt;

&lt;p&gt;因为 sets 只定义了部分排序功能（subset 关系），list.sort() 方法的输出对于 sets 的列表没有定义。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hash(s) # 返回 s 的 hash 值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面这个表列出了对于 Set 可用二对于 ImmutableSet 不可用的运算：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;运算符（voperator）&lt;/th&gt;
      &lt;th&gt;等价于&lt;/th&gt;
      &lt;th&gt;运算结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;s.update(t)&lt;/td&gt;
      &lt;td&gt;s |= t&lt;/td&gt;
      &lt;td&gt;返回增加了 set “t”中元素后的 set “s”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s.intersection_update(t)&lt;/td&gt;
      &lt;td&gt;s &amp;amp;= t&lt;/td&gt;
      &lt;td&gt;返回只保留含有 set “t”中元素的 set “s”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s.difference_update(t)&lt;/td&gt;
      &lt;td&gt;s -= t&lt;/td&gt;
      &lt;td&gt;返回删除了 set “t”中含有的元素后的 set “s”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s.symmetric_difference_update(t)&lt;/td&gt;
      &lt;td&gt;s ^= t&lt;/td&gt;
      &lt;td&gt;返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s.add(x)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;向 set “s”中增加元素 x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s.remove(x)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;从 set “s”中删除元素 x, 如果不存在则引发 KeyError&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s.discard(x)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;如果在 set “s”中存在元素 x, 则删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s.pop()&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s.clear()&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;删除 set “s”中的所有元素&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;请注意：非运算符版本的 update(), intersection_update(), difference_update()和symmetric_difference_update()将会接受任意 iterable 作为参数。从 2.3.1 版本做的更改：以前所有参数都必须是 sets。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;还请注意：这个模块还包含一个 union_update() 方法，它是 update() 方法的一个别名。包含这个方法是为了向后兼容。程序员们应该多使用 update() 方法，因为这个方法也被内置的 set() 和 frozenset() 类型支持。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;

</description>
        <pubDate>Fri, 03 Jun 2016 13:14:55 +0800</pubDate>
        <link>http://www.xiaoh.me/2016/06/03/python-set/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2016/06/03/python-set/</guid>
        
        <category>Python</category>
        
        <category>Set</category>
        
        
      </item>
    
      <item>
        <title>同步，异步，阻塞和非阻塞的理解</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在软件架构过程中经常会遇到数据的同步异步问题，还会牵扯到阻塞和非阻塞的问题，这个理解上很多时候我们会将概念混为一谈，这里简单区分一下其中的不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;概念&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;同步是两个对象之间的关系，而阻塞是一个对象的状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-1&quot;&gt;同步，异步&lt;/h5&gt;

&lt;p&gt;访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步和异步关注的是消息通信机制&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-2&quot;&gt;阻塞，非阻塞&lt;/h5&gt;

&lt;p&gt;进程/线程要访问的数据是否就绪，进程/线程是否需要等待&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;区分&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在处理 IO 的时候，阻塞和非阻塞都是同步 IO。&lt;/li&gt;
  &lt;li&gt;只有使用了特殊的 API 才是异步 IO。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.xiaoh.me/img/post-sync.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;同步和异步&lt;/h3&gt;

&lt;p&gt;同步就是两种东西通过一种机制实现步调一致，异步是两种东西不必步调一致&lt;/p&gt;

&lt;h5 id=&quot;section-5&quot;&gt;同步调用与异步调用&lt;/h5&gt;

&lt;p&gt;所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是&lt;strong&gt;一旦调用返回，就得到返回值了&lt;/strong&gt;。换句话说，就是由调用者主动等待这个调用的结果。&lt;/p&gt;

&lt;p&gt;而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过&lt;strong&gt;状态&lt;/strong&gt;、&lt;strong&gt;通知&lt;/strong&gt;来通知调用者，或通过&lt;strong&gt;回调函数&lt;/strong&gt;处理这个调用。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;同步就是打电话：我给你说了话，我就等着你说，你不说我不知道该说啥 &lt;strong&gt;请求线程会等待请求结果&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;异步就是邮件，QQ，短信：我给了你请求，我就去干别的，你爱啥时候回啥时候回 &lt;strong&gt;请求线程不会等待请求结果。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;section-6&quot;&gt;同步线程与异步线程&lt;/h5&gt;

&lt;p&gt;&lt;em&gt;同步线程&lt;/em&gt;：即两个线程步调要一致，要相互协商。两个线程的运行进度各不相同，怎么才能步调一致呢？我们直观的理解就是，快的等慢的呗！快的阻塞一下等到慢的步调一致即可。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;异步线程&lt;/em&gt;：步调不用一致，各自按各自的步调运行，不受另一个线程的影响。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步是指两个线程的运行是相关的，其中一个线程可能要阻塞等待另外一个线程的运行&lt;/li&gt;
  &lt;li&gt;异步的意思是两个线程毫无相关，自己运行自己的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-7&quot;&gt;同步通信与异步通信&lt;/h5&gt;

&lt;p&gt;这里的同步和异步是指：&lt;strong&gt;发送方和接收方是否协调步调一致&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同步通信是指&lt;/strong&gt;：发送方和接收方通过一定机制，实现收发步调协调。如：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;异步通信是指&lt;/strong&gt;：发送方的发送不管接收方的接收状态，如：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-8&quot;&gt;阻塞和非阻塞&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。&lt;/li&gt;
  &lt;li&gt;非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;阻塞就是这个事情阻到这儿了，不能继续往下干事了，非阻塞就是这个事情不会阻碍你继续干后面的事情。&lt;/p&gt;

&lt;p&gt;阻塞可以是实现同步的一种手段！例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-9&quot;&gt;例子&lt;/h3&gt;

&lt;p&gt;你打电话问书店老板有没有《分布式系统》这本书，如果是&lt;strong&gt;同步通信机制&lt;/strong&gt;，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。&lt;/p&gt;

&lt;p&gt;而&lt;strong&gt;异步通信机制&lt;/strong&gt;，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。&lt;/p&gt;

&lt;p&gt;你打电话问书店老板有没有《分布式系统》这本书，你如果是&lt;strong&gt;阻塞式调用&lt;/strong&gt;，你会一直把自己“挂起”，直到得到这本书有没有的结果。&lt;/p&gt;

&lt;p&gt;如果是&lt;strong&gt;非阻塞式调用&lt;/strong&gt;，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。&lt;/p&gt;

&lt;p&gt;在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-10&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19732473&quot;&gt;https://www.zhihu.com/question/19732473&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;

</description>
        <pubDate>Tue, 31 May 2016 14:34:56 +0800</pubDate>
        <link>http://www.xiaoh.me/2016/05/31/sync-async/</link>
        <guid isPermaLink="true">http://www.xiaoh.me/2016/05/31/sync-async/</guid>
        
        <category>Sync</category>
        
        <category>Async</category>
        
        
      </item>
    
  </channel>
</rss>
