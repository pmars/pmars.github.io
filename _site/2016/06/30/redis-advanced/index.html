<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="死生切阔，与子成说，执子之手，与子偕老。| 这里是 Xiaoh 的个人博客 | 外接各种互联网项目">
    <meta name="keyword"  content="兴明, xiaoh, pmars, itpmars, topmars, xiaoh's Blog, 博客, 个人网站, 互联网, 开发, 产品, 后端技术，架构">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Redis进阶教程 - Xiaoh写文字的地方 | Xiaoh's Blog</title>

    <link rel="canonical" href="http://www.xiaoh.me/2016/06/30/redis-advanced/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Xiaoh's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post-bg-default.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/post-bg-default.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#数据库" title="数据库">数据库</a>
                        
                        <a class="tag" href="/tags/#Redis" title="Redis">Redis</a>
                        
                    </div>
                    <h1>Redis进阶教程</h1>
                    
                    
                    <h2 class="subheading">总结一下Redis的高级用法</h2>
                    
                    <span class="meta">Posted by xiaoh on June 30, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<h3 id="section">目录</h3>

<ol>
  <li><a href="#summary">简介</a></li>
  <li><a href="#sort">排序</a></li>
  <li><a href="#transaction">事物</a></li>
  <li><a href="#pipeline">管道</a></li>
  <li><a href="#subpub">发布/订阅</a></li>
  <li><a href="#persistence">持久化</a></li>
  <li><a href="#master-slave">主从复制</a></li>
  <li><a href="#swapmemory">虚拟内存</a></li>
  <li><a href="#documents">文档</a></li>
</ol>

<hr />

<blockquote>
  <p>关于Redis的简述可以查看以前的博客 <a href="http://www.xiaoh.me/2015/12/17/redis-summary/">http://www.xiaoh.me/2015/12/17/redis-summary/</a></p>
</blockquote>

<hr />

<h3 id="summary"><a href="#summary">简介</a></h3>

<p>Redis是一个开源的<code class="highlighter-rouge">key-value</code>数据库。它又经常被认为是一个数据结构服务器。因为它的<code class="highlighter-rouge">value</code>不仅包括基本的<code class="highlighter-rouge">string</code>类型还有<code class="highlighter-rouge">list</code>,<code class="highlighter-rouge">set</code> ,<code class="highlighter-rouge">sorted set</code>和<code class="highlighter-rouge">hash</code>类型。当然这些类型的元素也都是<code class="highlighter-rouge">string</code>类型。也就是说<code class="highlighter-rouge">list</code>,<code class="highlighter-rouge">set</code>这些集合类型也只能包含<code class="highlighter-rouge">string</code>类型。</p>

<p>你可以在这些类型上做很多原子性的操作。比如对一个字符<code class="highlighter-rouge">value</code>追加字符串（<code class="highlighter-rouge">APPEND</code>命令）。加加或者减减一个数字字符串(<code class="highlighter-rouge">INCR</code>命令，当然是按整数处理的).可以对<code class="highlighter-rouge">list</code>类型进行<code class="highlighter-rouge">push</code>,或者<code class="highlighter-rouge">pop</code>元素操作（可以模拟栈和队列）。对于<code class="highlighter-rouge">set</code>类型可以进行一些集合相关操作 (<code class="highlighter-rouge">intersection union difference</code>)。</p>

<p><code class="highlighter-rouge">memcache</code>也有类似与<code class="highlighter-rouge">++</code>,<code class="highlighter-rouge">--</code>的命令。不过<code class="highlighter-rouge">memcache</code>的<code class="highlighter-rouge">value</code>只包括<code class="highlighter-rouge">string</code>类型。远没有<code class="highlighter-rouge">redis</code>的<code class="highlighter-rouge">value</code>类型丰富。和<code class="highlighter-rouge">memcahe</code>一样为了性能。<code class="highlighter-rouge">redis</code>的数据通常都是放到内存中的。当然<code class="highlighter-rouge">redis</code>可以每间隔一定时间将内存中数据写入到磁盘以防止数据丢失。</p>

<p><code class="highlighter-rouge">redis</code>也支持主从复制机制（<code class="highlighter-rouge">master-slave replication</code>）。<code class="highlighter-rouge">redis</code>的其他特性包括简单的事务支持和发布订阅(<code class="highlighter-rouge">pub/sub</code>)通道功能,而且<code class="highlighter-rouge">redis</code>配置管理非常简单。还有各种语言版本的开源客户端类库。</p>

<p>一些简单的使用方法可以参照以前的博客<a href="http://www.xiaoh.me/2015/12/17/redis-summary/">http://www.xiaoh.me/2015/12/17/redis-summary/</a>，这里就不再嗷述。</p>

<hr />

<h3 id="sort"><a href="#sort">排序</a></h3>

<p><code class="highlighter-rouge">redis</code>支持对<code class="highlighter-rouge">list</code>，<code class="highlighter-rouge">set</code>和<code class="highlighter-rouge">sorted set</code>元素的排序。排序命令是<code class="highlighter-rouge">sort</code> 完整的命令格式如下</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; help sort

  SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]
  summary: Sort the elements in a list, set or sorted set
  since: 1.0.0
  group: generic

127.0.0.1:6379&gt;
</code></pre>
</div>

<h5 id="sort-key">sort key</h5>

<p>这种是直接对一个数据结构进行排序</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; rpush l 3 4 1 5 2
(integer) 5
127.0.0.1:6379&gt; lrange l 0 5
1) "3"
2) "4"
3) "1"
4) "5"
5) "2"
127.0.0.1:6379&gt; sort l
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379&gt;
</code></pre>
</div>

<p>对set进行添加变量的时候，他会自动排序，所以用不到sort这种简单的功能。</p>

<h5 id="ascdesc-alpha">[ASC|DESC] [ALPHA]</h5>

<p><code class="highlighter-rouge">sort</code>默认的排序方式（<code class="highlighter-rouge">asc</code>）是从小到大排的,当然也可以按照逆序或者按字符顺序排。逆序可以加上<code class="highlighter-rouge">desc</code>选项，想按字母顺序排可以加<code class="highlighter-rouge">alpha</code>选项，当然<code class="highlighter-rouge">alpha</code>可以和<code class="highlighter-rouge">desc</code>一起用。下面是个按字母顺序排的例子</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; lpush l xiaoh huo xingming beijing changping
(integer) 5
127.0.0.1:6379&gt; lrange l 0 5
1) "changping"
2) "beijing"
3) "xingming"
4) "huo"
5) "xiaoh"
127.0.0.1:6379&gt; sort l alpha
1) "beijing"
2) "changping"
3) "huo"
4) "xiaoh"
5) "xingming"
127.0.0.1:6379&gt; sort l alpha desc
1) "xingming"
2) "xiaoh"
3) "huo"
4) "changping"
5) "beijing"
127.0.0.1:6379&gt;
</code></pre>
</div>

<h5 id="by-pattern">[BY pattern]</h5>

<p>Redis 支持将集合元素内容按照给定的<code class="highlighter-rouge">pattern</code>进行组合成新的KEY, 并按照新的KEY的对应内容进行排序，如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; lpush l e s g f a
(integer) 5
127.0.0.1:6379&gt; lrange l 0 9
1) "a"
2) "f"
3) "g"
4) "s"
5) "e"
127.0.0.1:6379&gt; sort l alpha
1) "a"
2) "e"
3) "f"
4) "g"
5) "s"
127.0.0.1:6379&gt; set namea 4
OK
127.0.0.1:6379&gt; set namee 5
OK
127.0.0.1:6379&gt; set namef 3
OK
127.0.0.1:6379&gt; set nameg 1
OK
127.0.0.1:6379&gt; set names 2
OK
127.0.0.1:6379&gt; sort l by name*
1) "g"
2) "s"
3) "f"
4) "a"
5) "e"
127.0.0.1:6379&gt; set namea xiaoh
OK
127.0.0.1:6379&gt; set namee me
OK
127.0.0.1:6379&gt; set namef huo
OK
127.0.0.1:6379&gt; set nameg blog
OK
127.0.0.1:6379&gt; set names xingming
OK
127.0.0.1:6379&gt; sort l by name* alpha
1) "g"
2) "f"
3) "e"
4) "a"
5) "s"
127.0.0.1:6379&gt;
</code></pre>
</div>

<p>以上实验了数字和字母的对应KEY，可以看出，在生成对应的新kEY之后，按照对应的内容进行了排序，并且返回的是原来的key的排序。</p>

<h5 id="get-pattern">[GET PATTERN]</h5>

<p>上面的方法返回的是原始的数据内容，如果想获得新的KEY对应的值（也就是进行排序的KEY）可以使用 GET PATTERN</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; sort l by name* alpha get name*
1) "blog"
2) "huo"
3) "me"
4) "xiaoh"
5) "xingming"
127.0.0.1:6379&gt; sort l by name* alpha get name* get #
 1) "blog"
 2) "g"
 3) "huo"
 4) "f"
 5) "me"
 6) "e"
 7) "xiaoh"
 8) "a"
 9) "xingming"
10) "s"
127.0.0.1:6379&gt;
</code></pre>
</div>

<p>GET 可以多次使用，上面就是一个例子，获取新的对应值的时候，将原始的内容也进行了获取。</p>

<p>也可以根据自己的内容排序，之后获取对应PATTERN值得列表</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; sort l alpha
1) "a"
2) "e"
3) "f"
4) "g"
5) "s"
127.0.0.1:6379&gt; sort l alpha get name*
1) "xiaoh"
2) "me"
3) "huo"
4) "blog"
5) "xingming"
127.0.0.1:6379&gt;
</code></pre>
</div>

<p>这里的GET还可以获取对象中的一个字段的值（hash可以作为对象来使用）使用特殊字符<code class="highlighter-rouge">-&gt;</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; lpush l 5 3 4 2 1
(integer) 5
127.0.0.1:6379&gt; hset user1 name this
(integer) 1
127.0.0.1:6379&gt; hset user4 name xiaoh
(integer) 1
127.0.0.1:6379&gt; hset user2 name blog
(integer) 1
127.0.0.1:6379&gt; hset user5 name me
(integer) 1
127.0.0.1:6379&gt; hset user3 name from
(integer) 1
127.0.0.1:6379&gt; sort l get user*-&gt;name
1) "this"
2) "blog"
3) "from"
4) "xiaoh"
5) "me"
127.0.0.1:6379&gt;
</code></pre>
</div>

<p>如果对应的hash对象不存在，会返回<code class="highlighter-rouge">(nil)</code></p>

<h5 id="limit-start-count">[LIMIT start count]</h5>

<p>默认排序结果全部显示，可以使用LIMIT来限制显示的数量，下标start默认从0开始</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; sort l limit 2 3
1) "3"
2) "4"
3) "5"
127.0.0.1:6379&gt;

127.0.0.1:6379&gt; sort l get user*-&gt;name limit 1 3
1) "blog"
2) "from"
3) "xiaoh"
127.0.0.1:6379&gt;
</code></pre>
</div>

<h5 id="store-dstkey">[STORE dstkey]</h5>

<p>如果对集合经常按照固定的模式去排序，那么把排序结果缓存起来会减少不少<code class="highlighter-rouge">cpu</code>开销.使用<code class="highlighter-rouge">store</code>选项可以将排序内容保存到指定<code class="highlighter-rouge">key</code>中。保存的类型是<code class="highlighter-rouge">list</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; sort l get user*-&gt;name limit 1 3 store dst
(integer) 3
127.0.0.1:6379&gt; lrange dst 0 -1
1) "blog"
2) "from"
3) "xiaoh"
127.0.0.1:6379&gt;
</code></pre>
</div>

<p>功能介绍完后，再讨论下关于排序的一些问题。如果我们有多个<code class="highlighter-rouge">redis server</code>的话，不同的<code class="highlighter-rouge">key</code>可能存在于不同的<code class="highlighter-rouge">server</code>上。比如name1 name2 name3 name4 name5，很有可能分别在多个不同的<code class="highlighter-rouge">server</code>上存贮着。这种情况会对排序性能造成很大的影响。</p>

<p><code class="highlighter-rouge">redis</code>作者在他的<code class="highlighter-rouge">blog</code>上提到了这个问题的解决办法，就是通过<code class="highlighter-rouge">key tag</code>将需要排序的<code class="highlighter-rouge">key</code>都放到同一个<code class="highlighter-rouge">server</code>上 。</p>

<p>由于具体决定哪个<code class="highlighter-rouge">key</code>存在哪个服务器上一般都是在<code class="highlighter-rouge">client</code>端<code class="highlighter-rouge">hash</code>的办法来做的。我们可以通过只对<code class="highlighter-rouge">key</code>的部分进行<code class="highlighter-rouge">hash</code>.</p>

<p>举个例子假如我们的<code class="highlighter-rouge">client</code>如果发现<code class="highlighter-rouge">key</code>中包含<code class="highlighter-rouge">[]</code>。那么只对<code class="highlighter-rouge">key</code>中<code class="highlighter-rouge">[]</code>包含的内容进行<code class="highlighter-rouge">hash</code>。我们将四个<code class="highlighter-rouge">name</code>相关的<code class="highlighter-rouge">key</code>，都这样命名<code class="highlighter-rouge">[name]1 [name]2 [name]3 [name]4 [name]5</code>，于是<code class="highlighter-rouge">client</code>程序就会把他们都放到同一<code class="highlighter-rouge">server</code>上。</p>

<p>还有一个问题也比较严重。如果要<code class="highlighter-rouge">sort</code>的集合非常大的话排序就会消耗很长时间。由于<code class="highlighter-rouge">redis</code>单线程的，所以长时间的排序操作会阻塞其他<code class="highlighter-rouge">client</code>的请求。解决办法是通过主从复制机制将数据复制到多个<code class="highlighter-rouge">slave</code>上。然后我们只在<code class="highlighter-rouge">slave</code>上做排序操作。并进可能的对排序结果缓存。另外就是一个方案是就是采用<code class="highlighter-rouge">sorted set</code>对需要按某个顺序访问的集合建立索引。</p>

<hr />

<h3 id="transaction"><a href="#transaction">事物</a></h3>

<p><code class="highlighter-rouge">redis</code>对事务的支持目前还比较简单。<code class="highlighter-rouge">redis</code>只能保证一个<code class="highlighter-rouge">client</code>发起的事务中的命令可以连续的执行，而中间不会插入其他<code class="highlighter-rouge">client</code>的命令。由于<code class="highlighter-rouge">redis</code>是单线程来处理所有<code class="highlighter-rouge">client</code>的请求的所以做到这点是很容易的。</p>

<h5 id="multi">multi</h5>

<p>一般情况下<code class="highlighter-rouge">redis</code>在接受到一个<code class="highlighter-rouge">client</code>发来的命令后会立即处理并返回处理结果，但是当一个<code class="highlighter-rouge">client</code>在一个连接中发出<code class="highlighter-rouge">multi</code>命令，这个连接会进入一个事务上下文，该连接后续的命令并不是立即执行，而是先放到一个队列中。当从此连接受到<code class="highlighter-rouge">exec</code>命令后，<code class="highlighter-rouge">redis</code>会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到一起返回给<code class="highlighter-rouge">client</code>.然后此连接就结束事务上下文.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; incr a
QUEUED
127.0.0.1:6379&gt; incr a
QUEUED
127.0.0.1:6379&gt; incr b
QUEUED
127.0.0.1:6379&gt; exec
1) (integer) 1
2) (integer) 2
3) (integer) 1
127.0.0.1:6379&gt;
</code></pre>
</div>

<p>例子中已经说明，当执行<code class="highlighter-rouge">incr a</code> <code class="highlighter-rouge">incr b</code> 的时候，是放到了队列里面，当<code class="highlighter-rouge">exec</code>时，执行了队列中的命令。</p>

<p>当事物写到一半，可以用<code class="highlighter-rouge">discard</code>来取消事物</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; incr a
QUEUED
127.0.0.1:6379&gt; incr b
QUEUED
127.0.0.1:6379&gt; discard
OK
127.0.0.1:6379&gt; get a
"2"
127.0.0.1:6379&gt; get b
"1"
127.0.0.1:6379&gt;
</code></pre>
</div>

<p>可以发现这次<code class="highlighter-rouge">incr a</code> <code class="highlighter-rouge">incr b</code>都没被执行。<code class="highlighter-rouge">discard</code>命令其实就是清空事务的命令队列并退出事务上下文</p>

<h5 id="watch">watch</h5>

<p><code class="highlighter-rouge">Watch</code> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; watch a
OK
127.0.0.1:6379&gt; get a
"5"
127.0.0.1:6379&gt; set a 6
OK
127.0.0.1:6379&gt; incr a
(integer) 7
127.0.0.1:6379&gt; get a
"7"
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; set a 2
QUEUED
127.0.0.1:6379&gt; exec
(nil)
127.0.0.1:6379&gt; get a
"7"
127.0.0.1:6379&gt;
</code></pre>
</div>

<p><code class="highlighter-rouge">exec</code> <code class="highlighter-rouge">discard</code> <code class="highlighter-rouge">unwatch</code> 会清除 <code class="highlighter-rouge">watch</code> 的监听</p>

<h5 id="section-1">缺点</h5>

<p><code class="highlighter-rouge">redis</code>的事务实现是如此简单，当然会存在一些问题。第一个问题是<code class="highlighter-rouge">redis</code>只能保证事务的每个命令连续执行，但是如果事务中的一个命令失败了，并不回滚其他命令，比如使用的命令类型不匹配。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>127.0.0.1:6379&gt; set b 1
OK
127.0.0.1:6379&gt; set a e
OK
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; incr a
QUEUED
127.0.0.1:6379&gt; incr b
QUEUED
127.0.0.1:6379&gt; exec
1) (error) ERR value is not an integer or out of range
2) (integer) 2
127.0.0.1:6379&gt;
</code></pre>
</div>

<p>可以发现，虽然执行中间有问题，但并没有回滚，其他命令还是执行了。</p>

<p>最后一个十分罕见的问题是，当事务的执行过程中，如果<code class="highlighter-rouge">redis</code>意外的挂了。很遗憾只有部分命令执行了，后面的也就被丢弃了。当然如果我们使用的<code class="highlighter-rouge">append-only file</code>方式持久化，<code class="highlighter-rouge">redis</code>会用单个<code class="highlighter-rouge">write</code>操作写入整个事务内容。即是是这种方式还是有可能只部分写入了事务到磁盘。发生部分写入事务的情况下，<code class="highlighter-rouge">redis</code>重启时会检测到这种情况，然后失败退出。可以使用<code class="highlighter-rouge">redis-check-aof</code>工具进行修复，修复会删除部分写入的事务内容。修复完后就能够重新启动了。</p>

<hr />

<h3 id="pipeline"><a href="#pipeline">管道</a></h3>

<p><code class="highlighter-rouge">redis</code>是一个<code class="highlighter-rouge">cs</code>模式的<code class="highlighter-rouge">tcp server</code>，使用和<code class="highlighter-rouge">http</code>类似的请求响应协议。</p>

<p>一个<code class="highlighter-rouge">client</code>可以通过一个<code class="highlighter-rouge">socket</code>连接发起多个请求命令。每个请求命令发出后<code class="highlighter-rouge">client</code>通常会阻塞并等待<code class="highlighter-rouge">redis</code>服务处理，<code class="highlighter-rouge">redis</code>处理完后请求命令后会将结果通过响应报文返回给<code class="highlighter-rouge">client</code>。基本的通信过程如下</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Client: INCR X
Server: 1
Client: INCR X
Server: 2
Client: INCR X
Server: 3
Client: INCR X
Server: 4
</code></pre>
</div>

<p>基本上四个命令需要8个<code class="highlighter-rouge">tcp</code>报文才能完成。由于通信会有网络延迟,假如从<code class="highlighter-rouge">client</code>和<code class="highlighter-rouge">server</code>之间的包传输时间需要0.125秒。那么上面的四个命令8个报文至少会需要1秒才能完成。这样即使<code class="highlighter-rouge">redis</code>每秒能处理100个命令，而我们的<code class="highlighter-rouge">client</code>也只能一秒钟发出四个命令。这显示没有充分利用<code class="highlighter-rouge">redis</code>的处理能力。除了可以利用<code class="highlighter-rouge">mget</code>,<code class="highlighter-rouge">mset</code>之类的单条命令处理多个<code class="highlighter-rouge">key</code>的命令外我们还可以利用<code class="highlighter-rouge">pipeline</code>的方式从<code class="highlighter-rouge">client</code>打包多条命令一起发出，不需要等待单条命令的响应返回，而<code class="highlighter-rouge">redis</code>服务端会处理完多条命令后会将多条命令的处理结果打包到一起返回给客户端。通信过程如下</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Client: INCR X
Client: INCR X
Client: INCR X
Client: INCR X
Server: 1
Server: 2
Server: 3
Server: 4
</code></pre>
</div>

<p>假设不会因为<code class="highlighter-rouge">tcp</code>报文过长而被拆分。可能两个<code class="highlighter-rouge">tcp</code>报文就能完成四条命令,<code class="highlighter-rouge">client</code>可以将四个<code class="highlighter-rouge">incr</code>命令放到一个<code class="highlighter-rouge">tcp</code>报文一起发送，<code class="highlighter-rouge">server</code>则可以将四条命令的处理结果放到一个<code class="highlighter-rouge">tcp</code>报文返回。</p>

<p>通过<code class="highlighter-rouge">pipeline</code>方式当有大批量的操作时候。我们可以节省很多原来浪费在网络延迟的时间。需要注意到是用<code class="highlighter-rouge">pipeline</code>方式打包命令发送，<code class="highlighter-rouge">redis</code>必须在处理完所有命令前先缓存起所有命令的处理结果。打包的命令越多，缓存消耗内存也越多。所以并是不是打包的命令越多越好。具体多少合适需要根据具体情况测试。</p>

<p>下面是我测试是否使用pipeline的代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from redis import Redis
import time

r = Redis()

def without_pipeline(times=100000):
    r.set('a', 0)
    for i in range(times):
        r.incr('a')

def use_pipeline(times=100000):
    r.set('a', 0)
    r.set('a', 0)
    pip = r.pipeline()
    for i in range(times):
        pip.incr('a')
    pip.execute()

start = time.time()
without_pipeline()
end = time.time()
print 'without pipeline spendtime:%f' % (end-start)

start = time.time()
use_pipeline()
end = time.time()
print 'use pipeline spendtime:%f' % (end-start)
</code></pre>
</div>

<p>结果为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>without pipeline spendtime:4.221240
use pipeline spendtime:1.572646
</code></pre>
</div>

<p>看起来对效果提升还是很明显的。</p>

<hr />

<h3 id="subpub"><a href="#subpub">发布/订阅</a></h3>

<p>发布订阅(<code class="highlighter-rouge">pub/sub</code>)是一种消息通信模式，主要的目的是解耦消息发布者和消息订阅者之间的耦合，这点和设计模式中的观察者模式比较相似。</p>

<p><code class="highlighter-rouge">pub/sub</code>不仅仅解决发布者和订阅者直接代码级别耦合也解决两者在物理部署上的耦合。<code class="highlighter-rouge">redis</code>作为一个<code class="highlighter-rouge">pub/sub server</code>，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过<code class="highlighter-rouge">subscribe</code>和<code class="highlighter-rouge">psubscribe</code>命令向<code class="highlighter-rouge">redis server</code>订阅自己感兴趣的消息类型，<code class="highlighter-rouge">redis</code>将消息类型称为通道(<code class="highlighter-rouge">channel</code>)。当发布者通过<code class="highlighter-rouge">publish</code>命令向<code class="highlighter-rouge">redis server</code>发送特定类型的消息时。订阅该消息类型的全部<code class="highlighter-rouge">client</code>都会收到此消息。这里消息的传递是多对多的。一个<code class="highlighter-rouge">client</code>可以订阅多个<code class="highlighter-rouge">channel</code>,也可以向多个<code class="highlighter-rouge">channel</code>发送消息。</p>

<p><code class="highlighter-rouge">Pub/Sub</code>功能（<code class="highlighter-rouge">means Publish</code>, <code class="highlighter-rouge">Subscribe</code>）即发布及订阅功能。基于事件的系统中，<code class="highlighter-rouge">Pub/Sub</code>是目前广泛使用的通信模型，它采用事件作为基本的通信机制，提供大规模系统所要求的松散耦合的交互模式：订阅者(如客户端)以事件订阅的方式表达出它有兴趣接收的一个事件或一类事件；发布者(如服务器)可将订阅者感兴趣的事件随时通知相关订阅者。</p>

<p>Pub/Sub是可适用于可扩展要求高、松散耦合系统的分布式交互模型</p>

<p>在抽象层中，它的时间非耦合、空间非耦合和同步非耦合性可允许参与者不依赖另一个而独立操作，具有一定的可扩展性；然而在实现层，可扩展性仍受其他原因的牵制。</p>

<ul>
  <li>灵活的订阅要求复杂的过滤和路由算法</li>
  <li>高可用性开销（事件侦听、日志重传）；</li>
  <li>消息认可带来的网络流量消耗；</li>
  <li>庞大的订阅者数据带来的系统开销；</li>
</ul>

<p>基于事件的Pub/Sub中间件的开发与利用在一定程度上可以提高系统的效率。</p>

<p>以下是我的测试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># code
import time, redis

r = redis.StrictRedis()
p = r.pubsub()
channel = 'channel'

def handler(message):
    print 'Receive msg:%s' % message['data']

p.subscribe(**{channel:handler})

thread = p.run_in_thread(sleep_time=0.01)

time.sleep(60)
thread.stop()

# running script
python pubsub.py

# ipython
In [2]: import redis
In [3]: r = redis.StrictRedis()
In [5]: r.publish('channel', 'xiaoh.me')
Out[5]: 1L
In [6]: r.publish('channel', 'my name is xiaoh')
Out[6]: 1L

# script output
Receive msg:xiaoh.me
Receive msg:my name is xiaoh
</code></pre>
</div>

<p>以上进行了简单的测试。</p>

<hr />

<h3 id="persistence"><a href="#persistence">持久化</a></h3>

<p><code class="highlighter-rouge">Redis</code>是一个支持持久化的内存数据库，也就是说<code class="highlighter-rouge">redis</code>需要经常将内存中的数据同步到磁盘来保证持久化。<code class="highlighter-rouge">redis</code>支持两种持久化方式，一种是<code class="highlighter-rouge">Snapshotting</code>（快照）也是默认方式，另一种是<code class="highlighter-rouge">Append-only file</code>（缩写aof）的方式。下面分别介绍</p>

<h5 id="snapshotting">Snapshotting</h5>

<p>快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为<code class="highlighter-rouge">dump.rdb</code>。可以通过配置设置自动做快照持久化的方式。我们可以配置<code class="highlighter-rouge">redis</code>在n秒内如果超过m个key被修改就自动做快照，下面是默认的快照保存配置</p>

<div class="highlighter-rouge"><pre class="highlight"><code>save 900 1  #900秒内如果超过1个key被修改，则发起快照保存
save 300 10 #300秒内容如超过10个key被修改，则发起快照保存
save 60 10000
</code></pre>
</div>

<p>下面介绍详细的快照保存过程</p>

<ol>
  <li><code class="highlighter-rouge">redis</code>调用<code class="highlighter-rouge">fork</code>,现在有了子进程和父进程。</li>
  <li>父进程继续处理<code class="highlighter-rouge">client</code>请求，子进程负责将内存内容写入到临时文件。由于os的写时复制机制（<code class="highlighter-rouge">copy on write</code>)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数据是<code class="highlighter-rouge">fork</code>时刻整个数据库的一个快照。</li>
  <li>当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。</li>
</ol>

<p><code class="highlighter-rouge">client</code>也可以使用<code class="highlighter-rouge">save</code>或者<code class="highlighter-rouge">bgsave</code>命令通知<code class="highlighter-rouge">redis</code>做一次快照持久化。</p>

<p><code class="highlighter-rouge">save</code>操作是在主线程中保存快照的，由于<code class="highlighter-rouge">redis</code>是用一个主线程来处理所有 <code class="highlighter-rouge">client</code>的请求，这种方式会阻塞所有<code class="highlighter-rouge">client</code>请求。所以不推荐使用。另一点需要注意的是，每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步脏数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，可能会严重影响性能。</p>

<p>另外由于快照方式是在一定间隔时间做一次的，所以如果<code class="highlighter-rouge">redis</code>意外<code class="highlighter-rouge">down</code>掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用<code class="highlighter-rouge">aof</code>持久化方式。</p>

<h5 id="append-only-file">Append-only file</h5>

<p><code class="highlighter-rouge">aof</code>比快照方式有更好的持久化性，是由于在使用<code class="highlighter-rouge">aof</code>持久化方式时,<code class="highlighter-rouge">redis</code>会将每一个收到的写命令都通过<code class="highlighter-rouge">write</code>函数追加到文件中(默认是 <code class="highlighter-rouge">appendonly.aof</code>)。</p>

<p>当<code class="highlighter-rouge">redis</code>重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于os会在内核中缓存<code class="highlighter-rouge">write</code>做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉<code class="highlighter-rouge">redis</code>我们想要通过<code class="highlighter-rouge">fsync</code>函数强制os写入到磁盘的时机。有三种方式如下（默认是：每秒fsync一次）</p>

<ul>
  <li>appendonly yes           //启用aof持久化方式</li>
  <li>appendfsync always       //每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用</li>
  <li>appendfsync everysec     //每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐</li>
  <li>appendfsync no           //完全依赖os，性能最好,持久化没保证</li>
</ul>

<p><code class="highlighter-rouge">aof</code>的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用<code class="highlighter-rouge">incr test</code>命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条<code class="highlighter-rouge">set test 100</code>就够了。为了压缩aof的持久化文件。<code class="highlighter-rouge">redis</code>提供了<code class="highlighter-rouge">bgrewriteaof</code>命令。收到此命令<code class="highlighter-rouge">redis</code>将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。具体过程如下</p>

<ol>
  <li><code class="highlighter-rouge">redis</code>调用<code class="highlighter-rouge">fork</code> ，现在有父子两个进程</li>
  <li>子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令</li>
  <li>父进程继续处理<code class="highlighter-rouge">client</code>请求，除了把写命令写入到原来的<code class="highlighter-rouge">aof</code>文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。</li>
  <li>当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。</li>
  <li>现在父进程可以使用临时文件替换老的<code class="highlighter-rouge">aof</code>文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。</li>
</ol>

<p>需要注意到是重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,这点和快照有点类似。</p>

<hr />

<h3 id="master-slave"><a href="#master-slave">主从复制</a></h3>

<p><code class="highlighter-rouge">Redis</code>主从复制配置和使用都非常简单。通过主从复制可以允许多个<code class="highlighter-rouge">slave server</code>拥有和<code class="highlighter-rouge">master server</code>相同的数据库副本。</p>

<p>关于<code class="highlighter-rouge">redis</code>主从复制的一些特点</p>

<ol>
  <li><code class="highlighter-rouge">master</code>可以有多个<code class="highlighter-rouge">slave</code></li>
  <li>除了多个<code class="highlighter-rouge">slave</code>连到相同的<code class="highlighter-rouge">master</code>外，<code class="highlighter-rouge">slave</code>也可以连接其他<code class="highlighter-rouge">slave</code>形成图状结构</li>
  <li>主从复制不会阻塞<code class="highlighter-rouge">master</code>。也就是说当一个或多个<code class="highlighter-rouge">slave</code>与<code class="highlighter-rouge">master</code>进行初次同步数据时，<code class="highlighter-rouge">master</code>可以继续处理<code class="highlighter-rouge">client</code>发来的请求。相反<code class="highlighter-rouge">slave</code>在初次同步数据时则会阻塞不能处理client的请求。</li>
  <li>主从复制可以用来提高系统的可伸缩性,我们可以用多个<code class="highlighter-rouge">slave</code>专门用于<code class="highlighter-rouge">client</code>的读请求，比如<code class="highlighter-rouge">sort</code>操作可以使用<code class="highlighter-rouge">slave</code>来处理。也可以用来做简单的数据冗余</li>
  <li>可以在<code class="highlighter-rouge">master</code>禁用数据持久化，只需要注释掉<code class="highlighter-rouge">master</code>配置文件中的所有<code class="highlighter-rouge">save</code>配置，然后只在<code class="highlighter-rouge">slave</code>上配置数据持久化。</li>
</ol>

<p>下面介绍下主从复制的过程</p>

<p>当设置好<code class="highlighter-rouge">slave</code>服务器后，<code class="highlighter-rouge">slave</code>会建立和<code class="highlighter-rouge">master</code>的连接，然后发送<code class="highlighter-rouge">sync</code>命令。</p>

<p>无论是第一次同步建立的连接还是连接断开后的重新连接，<code class="highlighter-rouge">master</code>都会启动一个后台进程，将数据库快照保存到文件中，同时<code class="highlighter-rouge">master</code>主进程会开始收集新的写命令并缓存起来。后台进程完成写文件后，<code class="highlighter-rouge">master</code>就发送文件给<code class="highlighter-rouge">slave</code>，<code class="highlighter-rouge">slave</code>将文件保存到磁盘上，然后加载到内存恢复数据库快照到<code class="highlighter-rouge">slave</code>上。</p>

<p>接着<code class="highlighter-rouge">master</code>就会把缓存的命令转发给<code class="highlighter-rouge">slave</code>。而且后续<code class="highlighter-rouge">master</code>收到的写命令都会通过开始建立的连接发送给<code class="highlighter-rouge">slave</code>。</p>

<p>从<code class="highlighter-rouge">master</code>到<code class="highlighter-rouge">slave</code>的同步数据的命令和从<code class="highlighter-rouge">client</code>发送的命令使用相同的协议格式。当<code class="highlighter-rouge">master</code>和<code class="highlighter-rouge">slave</code>的连接断开时<code class="highlighter-rouge">slave</code>可以自动重新建立连接。</p>

<p>如果<code class="highlighter-rouge">master</code>同时收到多个<code class="highlighter-rouge">slave</code>发来的同步连接命令，只会使用启动一个进程来写数据库镜像，然后发送给所有<code class="highlighter-rouge">slave</code>。</p>

<p>配置slave服务器很简单，只需要在配置文件中加入如下配置</p>

<div class="highlighter-rouge"><pre class="highlight"><code>slaveof 192.168.1.1 6379  #指定master的ip和端口
</code></pre>
</div>

<hr />

<h3 id="swapmemory"><a href="#swapmemory">虚拟内存</a></h3>

<p>首先说明下<code class="highlighter-rouge">redis</code>的虚拟内存与<code class="highlighter-rouge">os</code>的虚拟内存不是一码事，但是思路和目的都是相同的。就是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出宝贵的内存空间用于其他需要访问的数据。尤其是对于<code class="highlighter-rouge">redis</code>这样的内存数据库，内存总是不够用的。除了可以将数据分割到多个<code class="highlighter-rouge">redis server</code>外。另外的能够提高数据库容量的办法就是使用<code class="highlighter-rouge">vm</code>把那些不经常访问的数据交换的磁盘上。</p>

<p>如果我们的存储的数据总是有少部分数据被经常访问，大部分数据很少被访问，对于网站来说确实总是只有少量用户经常活跃。当少量数据被经常访问时，使用vm不但能提高单台<code class="highlighter-rouge">redis server</code>数据库的容量，而且也不会对性能造成太多影响。</p>

<p><code class="highlighter-rouge">redis</code>没有使用<code class="highlighter-rouge">os</code>提供的虚拟内存机制而是自己在用户态实现了自己的虚拟内存机制,作者在自己的<code class="highlighter-rouge">blog</code>专门解释了其中原因。<a href="http://antirez.com/post/redis-virtual-memory-story.html">http://antirez.com/post/redis-virtual-memory-story.html</a></p>

<h5 id="section-2">主要的理由有两点</h5>

<ol>
  <li><code class="highlighter-rouge">os</code>的虚拟内存是已4k页面为最小单位进行交换的。而<code class="highlighter-rouge">redis</code>的大多数对象都远小于4k，所以一个os页面上可能有多个<code class="highlighter-rouge">redis</code>对象。另外<code class="highlighter-rouge">redis</code>的集合对象类型如<code class="highlighter-rouge">list</code>,<code class="highlighter-rouge">set</code>可能存在与多个os页面上。最终可能造成只有10%key被经常访问，但是所有<code class="highlighter-rouge">os</code>页面都会被<code class="highlighter-rouge">os</code>认为是活跃的，这样只有内存真正耗尽时os才会交换页面。</li>
  <li>相比于os的交换方式。<code class="highlighter-rouge">redis</code>可以将被交换到磁盘的对象进行压缩,保存到磁盘的对象可以去除指针和对象元数据信息。一般压缩后的对象会比内存中的对象小10倍。这样<code class="highlighter-rouge">redis</code>的vm会比os vm能少做很多io操作。</li>
</ol>

<h5 id="vm">下面是vm相关配置</h5>

<ul>
  <li>vm-enabled yes                    #开启vm功能</li>
  <li>vm-swap-file /tmp/redis.swap      #交换出来的value保存的文件路径/tmp/redis.swap</li>
  <li>vm-max-memory 1000000             #redis使用的最大内存上限，超过上限后redis开始交换value到磁盘文件中。</li>
  <li>vm-page-size 32                   #每个页面的大小32个字节</li>
  <li>vm-pages 134217728                #最多使用在文件中使用多少页面,交换文件的大小 = vm-page-size * vm-pages</li>
  <li>vm-max-threads 4                  #用于执行value对象换入换出的工作线程数量。0表示不使用工作线程（后面介绍)</li>
</ul>

<p><code class="highlighter-rouge">redis</code>的<code class="highlighter-rouge">vm</code>在设计上为了保证<code class="highlighter-rouge">key</code>的查找速度，只会将<code class="highlighter-rouge">value</code>交换到<code class="highlighter-rouge">swap</code>文件中。所以如果是内存问题是由于太多<code class="highlighter-rouge">value</code>很小的<code class="highlighter-rouge">key</code>造成的，那么<code class="highlighter-rouge">vm</code>并不能解决。</p>

<p>和os一样<code class="highlighter-rouge">redis</code>也是按页面来交换对象的。<code class="highlighter-rouge">redis</code>规定同一个页面只能保存一个对象。但是一个对象可以保存在多个页面中。</p>

<p>在<code class="highlighter-rouge">redis</code>使用的内存没超过<code class="highlighter-rouge">vm-max-memory</code>之前是不会交换任何<code class="highlighter-rouge">value</code>的。当超过最大内存限制后，<code class="highlighter-rouge">redis</code>会选择较老的对象。如果两个对象一样老会优先交换比较大的对象，精确的公式<code class="highlighter-rouge">swappability = age*log(size_in_memory)</code>。</p>

<p>对于<code class="highlighter-rouge">vm-page-size</code>的设置应该根据自己的应用将页面的大小设置为可以容纳大多数对象的大小。太大了会浪费磁盘空间，太小了会造成交换文件出现碎片。</p>

<p>对于交换文件中的每个页面，<code class="highlighter-rouge">redis</code>会在内存中对应一个<code class="highlighter-rouge">1bit</code>值来记录页面的空闲状态。所以像上面配置中页面数量(<code class="highlighter-rouge">vm-pages 134217728</code>)会占用16M内存用来记录页面空闲状态。`</p>

<p>vm-max-threads<code class="highlighter-rouge">表示用做交换任务的线程数量。如果大于0推荐设为服务器的</code>cpu core`的数量。如果是0则交换过程在主线程进行。</p>

<h5 id="vm-1">参数配置讨论完后，在来简单介绍下vm是如何工作的，</h5>

<h6 id="vm-max-threads0blocking-vm">当<code class="highlighter-rouge">vm-max-threads</code>设为0时(<code class="highlighter-rouge">Blocking VM</code>)</h6>

<p>** 换出 **</p>

<p>主线程定期检查发现内存超出最大上限后，会直接已阻塞的方式,将选中的对象保存到<code class="highlighter-rouge">swap</code>文件中，并释放对象占用的内存,此过程会一直重复直到下面条件满足</p>

<ol>
  <li>内存使用降到最大限制以下</li>
  <li><code class="highlighter-rouge">swap</code>文件满了</li>
  <li>几乎全部的对象都被交换到磁盘了</li>
</ol>

<p>** 换入 **</p>

<p>当有<code class="highlighter-rouge">client</code>请求<code class="highlighter-rouge">value</code>被换出的<code class="highlighter-rouge">key</code>时。主线程会以阻塞的方式从文件中加载对应的<code class="highlighter-rouge">value</code>对象，加载时此时会阻塞所以<code class="highlighter-rouge">client</code>。然后处理<code class="highlighter-rouge">client</code>的请求</p>

<h6 id="vm-max-threads0threaded-vm">当<code class="highlighter-rouge">vm-max-threads</code>大于0(<code class="highlighter-rouge">Threaded VM</code>)</h6>

<p>** 换出 **</p>

<p>当主线程检测到使用内存超过最大上限，会将选中的要交换的对象信息放到一个队列中交由工作线程后台处理，主线程会继续处理<code class="highlighter-rouge">client</code>请求。</p>

<p>** 换入 **</p>

<p>如果有<code class="highlighter-rouge">client</code>请求的<code class="highlighter-rouge">key</code>被换出了，主线程先阻塞发出命令的<code class="highlighter-rouge">client</code>,然后将加载对象的信息放到一个队列中，让工作线程去加载。加载完毕后工作线程通知主线程。主线程再执行<code class="highlighter-rouge">client</code>的命令。这种方式只阻塞请求<code class="highlighter-rouge">value</code>被换出<code class="highlighter-rouge">key</code>的<code class="highlighter-rouge">client</code></p>

<p>总的来说<code class="highlighter-rouge">blocking vm</code>的方式总的性能会好一些，因为不需要线程同步，创建线程和恢复被阻塞的<code class="highlighter-rouge">client</code>等开销。但是也相应的牺牲了响应性。<code class="highlighter-rouge">threaded vm</code>的方式主线程不会阻塞在磁盘io上，所以响应性更好。</p>

<p>如果我们的应用不太经常发生换入换出，而且也不太在意有点延迟的话则推荐使用<code class="highlighter-rouge">blocking vm</code>的方式。</p>

<p>关于<code class="highlighter-rouge">redis vm</code>的更详细介绍可以参考下面链接</p>

<ul>
  <li><a href="http://antirez.com/post/redis-virtual-memory-story.html">http://antirez.com/post/redis-virtual-memory-story.html</a></li>
  <li><a href="http://redis.io/topics/internals-vm">http://redis.io/topics/internals-vm</a></li>
</ul>

<hr />

<h3 id="documents"><a href="#documents">文档</a></h3>

<ul>
  <li><a href="http://redisdoc.com/index.html">http://redisdoc.com/index.html</a></li>
  <li><a href="https://github.com/andymccurdy/redis-py">https://github.com/andymccurdy/redis-py</a></li>
</ul>

<hr />

<h3 id="end">END</h3>



                <hr>

                


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/06/16/barrage-chat/" data-toggle="tooltip" data-placement="top" title="简单的弹幕聊天系统构建">
                        Previous<br>
                        <span>简单的弹幕聊天系统构建</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2017/04/14/git-service/" data-toggle="tooltip" data-placement="top" title="搭建GIT仓库服务器方法">
                        Next<br>
                        <span>搭建GIT仓库服务器方法</span>
                        </a>
                    </li>
                    
                </ul>


                

                

            </div>

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#杂谈" title="杂谈" rel="4">
                                    杂谈
                                </a>
                            
        				
                            
                				<a href="/tags/#Python" title="Python" rel="17">
                                    Python
                                </a>
                            
        				
                            
                				<a href="/tags/#Ubuntu" title="Ubuntu" rel="3">
                                    Ubuntu
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Flask" title="Flask" rel="3">
                                    Flask
                                </a>
                            
        				
                            
                				<a href="/tags/#Redis" title="Redis" rel="3">
                                    Redis
                                </a>
                            
        				
                            
                				<a href="/tags/#数据库" title="数据库" rel="2">
                                    数据库
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#Supervisor" title="Supervisor" rel="2">
                                    Supervisor
                                </a>
                            
        				
                            
                				<a href="/tags/#服务器" title="服务器" rel="6">
                                    服务器
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Lua" title="Lua" rel="2">
                                    Lua
                                </a>
                            
        				
                            
                				<a href="/tags/#Requests" title="Requests" rel="2">
                                    Requests
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Django" title="Django" rel="2">
                                    Django
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#AWK" title="AWK" rel="2">
                                    AWK
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#HBase" title="HBase" rel="2">
                                    HBase
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Thrift" title="Thrift" rel="2">
                                    Thrift
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Spider" title="Spider" rel="4">
                                    Spider
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Selenium" title="Selenium" rel="2">
                                    Selenium
                                </a>
                            
        				
                            
                				<a href="/tags/#PhantomJS" title="PhantomJS" rel="2">
                                    PhantomJS
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://pmars.cnblogs.com">pmars的博客</a></li>
                    
                        <li><a href="http://weibo.com/topmars">pmars的微博</a></li>
                    
                        <li><a href="http://github.com/pmars">我的项目</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>


<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/xiaoh">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/topmars">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/pmars">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Xiaoh's Blog 2018
                    <br>
                    Theme © <a href="http://xiaoh.me">Xiaoh</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=pmars&repo=pmars.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
    <div class="actGotop" style="">
        <div class="plane"></div>
        <div class="back-info">返回顶部</div>
    </div>
    <script>
        (function() {
            $(window).scroll(function(){
                if($(window).scrollTop()>500){
                    $('.actGotop').fadeIn();
                }else{
                    $('.actGotop').fadeOut();
                }
            }) 
            $('.actGotop').click(function(){
                $(window).scrollTop(0);
            });
        })();
    </script>
</footer>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- Highlight.js -->
<script>
    async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
        hljs.initHighlightingOnLoad();
    })
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>
<link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        // var $nav = document.querySelector("nav");
        // if($nav) FastClick.attach($nav);

        // global FastClick!!
        FastClick.attach(document.body);    
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-73800419-1';
    var _gaDomain = 'www.xiaoh.me';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'eb09bda7042f7733bd1bcba14d69d750';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
