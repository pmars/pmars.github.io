<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="死生切阔，与子成说，执子之手，与子偕老。| 这里是 Xiaoh 的个人博客 | 外接各种互联网项目">
    <meta name="keyword"  content="兴明, xiaoh, pmars, itpmars, topmars, xiaoh's Blog, 博客, 个人网站, 互联网, 开发, 产品, 后端技术，架构">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Requests高级用法 - Xiaoh写文字的地方 | Xiaoh's Blog</title>

    <link rel="canonical" href="http://www.xiaoh.me/2016/01/08/requests-advanced/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Xiaoh's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post-bg-requests-summary.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/post-bg-requests-summary.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#Requests" title="Requests">Requests</a>
                        
                    </div>
                    <h1>Requests高级用法</h1>
                    
                    
                    <h2 class="subheading">讲诉Requests的一些更加高级的特性</h2>
                    
                    <span class="meta">Posted by xiaoh on January 8, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<blockquote>
  <p>上一篇讲诉了 <a href="http://www.xiaoh.me/2016/01/08/requests-summary/">Requests入门教程</a><br />
这一篇说一下 Requests 的高级用法，其实也是转载的 <a href="http://cn.python-requests.org/en/latest/user/advanced.html">官方文档</a></p>
</blockquote>

<hr />

<h3 id="section">目录</h3>

<ol>
  <li><a href="#session">会话对象</a></li>
  <li><a href="#request">请求与响应对象</a></li>
  <li><a href="#prepared-requestsprepared">Prepared Requests</a></li>
  <li><a href="#sslssl">SSL证书验证</a></li>
  <li><a href="#workflow">响应体内容工作流</a></li>
  <li><a href="#linklong">保持活动状态（持久连接）</a></li>
  <li><a href="#flowupload">流式上传</a></li>
  <li><a href="#chunked">块编码请求</a></li>
  <li><a href="#post-multiple-multipartencoded-filesmultifiles">POST Multiple Multipart-Encoded Files</a></li>
  <li><a href="#hooks">事件挂钩</a></li>
  <li><a href="#auth">自定义身份验证</a></li>
  <li><a href="#flowrequest">流式请求</a></li>
  <li><a href="#proxy">代理</a></li>
  <li><a href="#rfc">合规性</a></li>
  <li><a href="#encoding">编码方式</a></li>
  <li><a href="#httphttpmethod">HTTP动词</a></li>
  <li><a href="#headlink">响应头链接字段</a></li>
  <li><a href="#transport-adapterstransportada">Transport Adapters</a></li>
  <li><a href="#example-specific-ssl-versionexample">Example: Specific SSL Version</a></li>
  <li><a href="#blocking-or-nonblockingblocking">Blocking Or Non-Blocking?</a></li>
  <li><a href="#timeoutstimeout">Timeouts</a></li>
  <li><a href="#ca-certificatescertificates">CA Certificates</a></li>
</ol>

<hr />

<h3 id="session"><a href="#session">会话对象</a></h3>

<p>会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookies。</p>

<p>会话对象具有主要的 Requests API 的所有方法。</p>

<p>我们来跨请求保持一些 cookies:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>s = requests.Session()

s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')
r = s.get("http://httpbin.org/cookies")

print(r.text)
# '{"cookies": {"sessioncookie": "123456789"}}'
</code></pre>
</div>

<p>会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>s = requests.Session()
s.auth = ('user', 'pass')
s.headers.update({'x-test': 'true'})

# both 'x-test' and 'x-test2' are sent
s.get('http://httpbin.org/headers', headers={'x-test2': 'true'})
</code></pre>
</div>

<p>任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。</p>

<blockquote>
  <p><strong>从字典参数中移除一个值</strong><br />
有时你会想省略字典参数中一些会话层的键。要做到这一点，你只需简单地在方法层参数中将那个键的值设置为 None ，那个键就会被自动省略掉。</p>
</blockquote>

<p>包含在一个会话中的所有数据你都可以直接使用。学习更多细节请阅读 <a href="http://cn.python-requests.org/en/latest/api.html#sessionapi">会话API文档</a> 。</p>

<hr />

<h3 id="request"><a href="#request">请求与响应对象</a></h3>

<p>任何时候调用 <code class="highlighter-rouge">requests.*()</code> 你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 requests 得到一个从 服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息， 也包含你原来创建的 Request 对象。如下是一个简单的请求，从 Wikipedia 的服务器得到 一些非常重要的信息:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ r = requests.get('http://en.wikipedia.org/wiki/Monty_Python')
</code></pre>
</div>

<p>如果想访问服务器返回给我们的响应头部信息，可以这样做:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ r.headers
{'content-length': '56170', 'x-content-type-options': 'nosniff', 'x-cache':
'HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet', 'content-encoding':
'gzip', 'age': '3080', 'content-language': 'en', 'vary': 'Accept-Encoding,Cookie',
'server': 'Apache', 'last-modified': 'Wed, 13 Jun 2012 01:33:50 GMT',
'connection': 'close', 'cache-control': 'private, s-maxage=0, max-age=0,
must-revalidate', 'date': 'Thu, 14 Jun 2012 12:59:39 GMT', 'content-type':
'text/html; charset=UTF-8', 'x-cache-lookup': 'HIT from cp1006.eqiad.wmnet:3128,
MISS from cp1010.eqiad.wmnet:80'}
</code></pre>
</div>

<p>然而，如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ r.request.headers
{'Accept-Encoding': 'identity, deflate, compress, gzip',
'Accept': '*/*', 'User-Agent': 'python-requests/0.13.1'}
</code></pre>
</div>

<hr />

<h3 id="prepared-requestsprepared"><a href="#prepared">Prepared Requests</a></h3>

<p>Whenever you receive a Response object from an API call or a Session call, the request attribute is actually the PreparedRequest that was used. In some cases you may wish to do some extra work to the body or headers (or anything else really) before sending a request. The simple recipe for this is the following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from requests import Request, Session

s = Session()
req = Request('GET', url,
    data=data,
    headers=header
)
prepped = req.prepare()

# do something with prepped.body
# do something with prepped.headers

resp = s.send(prepped,
    stream=stream,
    verify=verify,
    proxies=proxies,
    cert=cert,
    timeout=timeout
)

print(resp.status_code)
</code></pre>
</div>

<p>Since you are not doing anything special with the Request object, you prepare it immediately and modify the PreparedRequest object. You then send that with the other parameters you would have sent to <code class="highlighter-rouge">requests.*</code> or <code class="highlighter-rouge">Session.*</code>.</p>

<p>However, the above code will lose some of the advantages of having a Requests Session object. In particular, Session-level state such as cookies will not get applied to your request. To get a <code class="highlighter-rouge">PreparedRequest</code> with that state applied, replace the call to <code class="highlighter-rouge">Request.prepare()</code> with a call to <code class="highlighter-rouge">Session.prepare_request()</code>, like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from requests import Request, Session

s = Session()
req = Request('GET',  url,
    data=data
    headers=headers
)

prepped = s.prepare_request(req)

# do something with prepped.body
# do something with prepped.headers

resp = s.send(prepped,
    stream=stream,
    verify=verify,
    proxies=proxies,
    cert=cert,
    timeout=timeout
)

print(resp.status_code)
</code></pre>
</div>

<hr />

<h3 id="sslssl"><a href="#ssl">SSL证书验证</a></h3>

<p>Requests 可以为 HTTPS 请求验证 SSL 证书，就像 web 浏览器一样。要想检查某个主机的 SSL 证书，你可以使用 verify 参数:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ requests.get('https://kennethreitz.com', verify=True)
requests.exceptions.SSLError: hostname 'kennethreitz.com' doesn't match either of '*.herokuapp.com', 'herokuapp.com'
</code></pre>
</div>

<p>在该域名上我没有设置 SSL，所以失败了。但 Github 设置了 SSL:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ requests.get('https://github.com', verify=True)
&lt;Response [200]&gt;
</code></pre>
</div>

<p>对于私有证书，你也可以传递一个 <code class="highlighter-rouge">CA_BUNDLE</code> 文件的路径给 verify 。你也可以设置 <code class="highlighter-rouge">REQUEST_CA_BUNDLE</code> 环境变量。</p>

<p>如果你将 verify 设置为 False，Requests 也能忽略对 SSL 证书的验证。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ requests.get('https://kennethreitz.com', verify=False)
&lt;Response [200]&gt;
</code></pre>
</div>

<p>默认情况下， verify 是设置为 True 的。选项 verify 仅应用于主机证书。</p>

<p>你也可以指定一个本地证书用作客户端证书，可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ requests.get('https://kennethreitz.com', cert=('/path/server.crt', '/path/key'))
&lt;Response [200]&gt;
</code></pre>
</div>

<p>如果你指定了一个错误路径或一个无效的证书:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ requests.get('https://kennethreitz.com', cert='/wrong_path/server.pem')
SSLError: [Errno 336265225] _ssl.c:347: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib
</code></pre>
</div>

<hr />

<h3 id="workflow"><a href="#workflow">响应体内容工作流</a></h3>

<p>默认情况下，当你进行网络请求后，响应体会立即被下载。你可以通过 stream 参数覆盖这个行为，推迟下载响应体直到访问 <code class="highlighter-rouge">Response.content</code> 属性:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>tarball_url = 'https://github.com/kennethreitz/requests/tarball/master'
r = requests.get(tarball_url, stream=True)
</code></pre>
</div>

<p>此时仅有响应头被下载下来了，连接保持打开状态，因此允许我们根据条件获取内容:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>if int(r.headers['content-length']) &lt; TOO_LONG:
    content = r.content
    ...
</code></pre>
</div>

<p>你可以进一步使用 <code class="highlighter-rouge">Response.iter_content</code> 和 <code class="highlighter-rouge">Response.iter_lines</code> 方法来控制工作流，或者以 <code class="highlighter-rouge">Response.raw</code> 从底层 urllib3 的 <code class="highlighter-rouge">urllib3.HTTPResponse &lt; urllib3.response.HTTPResponse</code> 读取。</p>

<p>If you set stream to True when making a request, Requests cannot release the connection back to the pool unless you consume all the data or call <code class="highlighter-rouge">Response.close</code>. This can lead to inefficiency with connections. If you find yourself partially reading request bodies (or not reading them at all) while using <code class="highlighter-rouge">stream=True</code>, you should consider using <code class="highlighter-rouge">contextlib.closing</code> (documented here), like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from contextlib import closing

with closing(requests.get('http://httpbin.org/get', stream=True)) as r:
# Do things with the response here.
</code></pre>
</div>

<hr />

<h3 id="linklong"><a href="#linklong">保持活动状态（持久连接）</a></h3>

<p>好消息 - 归功于urllib3，同一会话内的持久连接是完全自动处理的！同一会话内你发出的任何请求都会自动复用恰当的连接！</p>

<p>注意：只有所有的响应体数据被读取完毕连接才会被释放为连接池；所以确保将 stream 设置为 False 或读取 Response 对象的 content 属性。</p>

<hr />

<h3 id="flowupload"><a href="#flowupload">流式上传</a></h3>

<p>Requests 支持流式上传，这允许你发送大的数据流或文件而无需先把它们读入内存。要使用流式上传，仅需为你的请求体提供一个类文件对象即可:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>with open('massive-body') as f:
    requests.post('http://some.url/streamed', data=f)
</code></pre>
</div>

<hr />

<h3 id="chunked"><a href="#chunked">块编码请求</a></h3>

<p>对于出去和进来的请求，Requests 也支持分块传输编码。要发送一个块编码的请求，仅需为你的请求体提供一个生成器（或任意没有具体长度(without a length)的迭代器）:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def gen():
    yield 'hi'
    yield 'there'

requests.post('http://some.url/chunked', data=gen())
</code></pre>
</div>

<hr />

<h3 id="post-multiple-multipart-encoded-filesmultifiles"><a href="#multifiles">POST Multiple Multipart-Encoded Files</a></h3>

<p>You can send multiple files in one request. For example, suppose you want to upload image files to an HTML form with a multiple file field ‘images’:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;input tLype=”file” name=”images” multiple=”true” required=”true”/&gt;
</code></pre>
</div>

<p>To do that, just set files to a list of tuples of (form_field_name, file_info):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ url = 'http://httpbin.org/post'
$ multiple_files = [('images', ('foo.png', open('foo.png', 'rb'), 'image/png')),
                  ('images', ('bar.png', open('bar.png', 'rb'), 'image/png'))]
$ r = requests.post(url, files=multiple_files)
$ r.text
{
  ...
  'files': {'images': 'data:image/png;base64,iVBORw ....'}
  'Content-Type': 'multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a',
  ...
}
</code></pre>
</div>

<hr />

<h3 id="hooks"><a href="#hooks">事件挂钩</a></h3>

<p>Requests 有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理。</p>

<p>可用的钩子:</p>

<ul>
  <li>response:</li>
</ul>

<h6 id="section-1">从一个请求产生的响应</h6>

<p>你可以通过传递一个 <code class="highlighter-rouge"><span class="p">{</span><span class="err">hook_name:</span><span class="w"> </span><span class="err">callback_function</span><span class="p">}</span></code> 字典给 hooks 请求参数 为每个请求分配一个钩子函数:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>hooks=dict(response=print_url)
</code></pre>
</div>

<p><code class="highlighter-rouge">callback_function</code> 会接受一个数据块作为它的第一个参数。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def print_url(r):
    print(r.url)
</code></pre>
</div>

<p>若执行你的回调函数期间发生错误，系统会给出一个警告。</p>

<p>若回调函数返回一个值，默认以该值替换传进来的数据。若函数未返回任何东西， 也没有什么其他的影响。</p>

<p>我们来在运行期间打印一些请求方法的参数:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ requests.get('http://httpbin.org', hooks=dict(response=print_url))
http://httpbin.org
&lt;Response [200]&gt;
</code></pre>
</div>

<hr />

<h3 id="auth"><a href="#auth">自定义身份验证</a></h3>

<p>Requests 允许你使用自己指定的身份验证机制。</p>

<p>任何传递给请求方法的 auth 参数的可调用对象，在请求发出之前都有机会修改请求。</p>

<p>自定义的身份验证机制是作为 <code class="highlighter-rouge">requests.auth.AuthBase</code> 的子类来实现的，也非常容易定义。</p>

<p>Requests 在 <code class="highlighter-rouge">requests.auth</code> 中提供了两种常见的的身份验证方案： <code class="highlighter-rouge">HTTPBasicAuth</code> 和 <code class="highlighter-rouge">HTTPDigestAuth</code> 。</p>

<p>假设我们有一个 web 服务，仅在 <code class="highlighter-rouge">X-Pizza</code> 头被设置为一个密码值的情况下才会有响应。虽然这不太可能， 但就以它为例好了</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from requests.auth import AuthBase

class PizzaAuth(AuthBase):
    """Attaches HTTP Pizza Authentication to the given Request object."""
    def __init__(self, username):
        # setup any auth-related data here
        self.username = username

    def __call__(self, r):
        # modify and return the request
        r.headers['X-Pizza'] = self.username
        return r
</code></pre>
</div>

<p>然后就可以使用我们的 <code class="highlighter-rouge">PizzaAuth</code> 来进行网络请求:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ requests.get('http://pizzabin.org/admin', auth=PizzaAuth('kenneth'))
&lt;Response [200]&gt;
</code></pre>
</div>

<hr />

<h3 id="flowrequest"><a href="#flowrequest">流式请求</a></h3>

<p>使用 <code class="highlighter-rouge">requests.Response.iter_lines()</code> 你可以很方便地对流式 API（例如 Twitter 的流式 API ）进行迭代。简单地设置 stream 为 True 便可以使用 <code class="highlighter-rouge">iter_lines()</code> 对相应进行迭代:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import json
import requests

r = requests.get('http://httpbin.org/stream/20', stream=True)

for line in r.iter_lines():

    # filter out keep-alive new lines
    if line:
        print(json.loads(line))
</code></pre>
</div>

<hr />

<h3 id="proxy"><a href="#proxy">代理</a></h3>

<p>如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import requests

proxies = {
  "http": "http://10.10.1.10:3128",
  "https": "http://10.10.1.10:1080",
}

requests.get("http://example.org", proxies=proxies)
</code></pre>
</div>

<p>你也可以通过环境变量 <code class="highlighter-rouge">HTTP_PROXY</code> 和 <code class="highlighter-rouge">HTTPS_PROXY</code> 来配置代理。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ export HTTP_PROXY="http://10.10.1.10:3128"
$ export HTTPS_PROXY="http://10.10.1.10:1080"
$ python
$ import requests
$ requests.get("http://example.org")
</code></pre>
</div>

<p>若你的代理需要使用 HTTP Basic Auth，可以使用 <code class="highlighter-rouge">http://user:password@host/</code> 语法:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>proxies = {
    "http": "http://user:pass@10.10.1.10:3128/",
}
</code></pre>
</div>

<hr />

<h3 id="rfc"><a href="#rfc">合规性</a></h3>

<p>Requests 符合所有相关的规范和RFC，这样不会为用户造成不必要的困难。但这种对规范的考虑 导致一些行为对于不熟悉相关规范的人来说看似有点奇怪。</p>

<hr />

<h3 id="encoding"><a href="#encoding">编码方式</a></h3>

<p>当你收到一个响应时，Requests 会猜测响应的编码方式，用于在你调用 <code class="highlighter-rouge">Response.text</code> 方法时 对响应进行解码。Requests 首先在 HTTP 头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。</p>

<p>只有当 HTTP 头部不存在明确指定的字符集，并且 <code class="highlighter-rouge">Content-Type</code> 头部字段包含 text 值之时， Requests 才不去猜测编码方式。</p>

<p>在这种情况下， <code class="highlighter-rouge">RFC 2616</code> 指定默认字符集 必须是 <code class="highlighter-rouge">ISO-8859-1</code> 。Requests 遵从这一规范。如果你需要一种不同的编码方式，你可以手动设置 <code class="highlighter-rouge">Response.encoding</code> 属性，或使用原始的 <code class="highlighter-rouge">Response.content</code> 。</p>

<hr />

<h3 id="httphttpmethod"><a href="#httpmethod">HTTP动词</a></h3>

<p>Requests 提供了几乎所有 HTTP 动词的功能：GET，OPTIONS， HEAD，POST，PUT，PATCH 和 DELETE。 以下内容为使用 Requests 中的这些动词以及 Github API 提供了详细示例。</p>

<p>我将从最常使用的动词GET开始。HTTP GET 是一个幂等的方法，从给定的 URL 返回一个资源。因而，当你试图从一个 web 位置获取数据之时，你应该使用这个动词。一个使用示例是尝试从 Github 上获取 关于一个特定 commit 的信息。假设我们想获取 Requests 的 commit a050faf 的信息。我们可以这样去做:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ import requests
$ r = requests.get('https://api.github.com/repos/kennethreitz/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad')
</code></pre>
</div>

<p>我们应该确认 Github 是否正确响应。如果正确响应，我们想弄清响应内容是什么类型的。像这样去做:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ if (r.status_code == requests.codes.ok):
    print r.headers['content-type']
application/json; charset=utf-8
</code></pre>
</div>

<p>可见，GitHub 返回了 JSON 数据，非常好，这样就可以使用 <code class="highlighter-rouge">r.json</code> 方法把这个返回的数据解析成 Python 对象。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ commit_data = r.json()
$ print commit_data.keys()
[u'committer', u'author', u'url', u'tree', u'sha', u'parents', u'message']
$ print commit_data[u'committer']
{u'date': u'2012-05-10T11:10:50-07:00', u'email': u'me@kennethreitz.com', u'name': u'Kenneth Reitz'}
$ print commit_data[u'message']
makin' history
</code></pre>
</div>

<p>到目前为止，一切都非常简单。嗯，我们来研究一下 GitHub 的 API。我们可以去看看文档， 但如果使用 Requests 来研究也许会更有意思一点。我们可以借助 Requests 的 OPTIONS 动词来看看我们刚使用过的 url 支持哪些 HTTP 方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ verbs = requests.options(r.url)
$ verbs.status_code
500
</code></pre>
</div>

<p>额，这是怎么回事？毫无帮助嘛！原来 GitHub，与许多 API 提供方一样，实际上并未实现 OPTIONS 方法。 这是一个恼人的疏忽，但没关系，那我们可以使用枯燥的文档。然而，如果 GitHub 正确实现了 OPTIONS， 那么服务器应该在响应头中返回允许用户使用的 HTTP 方法，例如</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ verbs = requests.options('http://a-good-website.com/api/cats')
$ print verbs.headers['allow']
GET,HEAD,POST,OPTIONS
</code></pre>
</div>

<p>转而去查看文档，我们看到对于提交信息，另一个允许的方法是 POST，它会创建一个新的提交。 由于我们正在使用 Requests 代码库，我们应尽可能避免对它发送笨拙的 POST。作为替代，我们来玩玩 GitHub 的 Issue 特性。</p>

<p>本篇文档是回应 <code class="highlighter-rouge">Issue #482</code> 而添加的。鉴于该问题已经存在，我们就以它为例。先获取它。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ r = requests.get('https://api.github.com/repos/kennethreitz/requests/issues/482')
$ r.status_code
200
$ issue = json.loads(r.text)
$ print issue[u'title']
Feature any http verb in docs
$ print issue[u'comments']
3
</code></pre>
</div>

<p>Cool，有3个评论。我们来看一下最后一个评论。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ r = requests.get(r.url + u'/comments')
$ r.status_code
200
$ comments = r.json()
$ print comments[0].keys()
[u'body', u'url', u'created_at', u'updated_at', u'user', u'id']
$ print comments[2][u'body']
Probably in the "advanced" section
</code></pre>
</div>

<p>嗯，那看起来似乎是个愚蠢之处。我们发表个评论来告诉这个评论者他自己的愚蠢。那么，这个评论者是谁呢？</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ print comments[2][u'user'][u'login']
kennethreitz
</code></pre>
</div>

<p>好，我们来告诉这个叫肯尼思的家伙，这个例子应该放在快速上手指南中。根据 <code class="highlighter-rouge">GitHub API</code> 文档， 其方法是 POST 到该话题。我们来试试看。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ body = json.dumps({u"body": u"Sounds great! I'll get right on it!"})
$ url = u"https://api.github.com/repos/kennethreitz/requests/issues/482/comments"
$ r = requests.post(url=url, data=body)
$ r.status_code
404
</code></pre>
</div>

<p>额，这有点古怪哈。可能我们需要验证身份。那就有点纠结了，对吧？不对。Requests 简化了多种身份验证形式的使用， 包括非常常见的 Basic Auth。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ from requests.auth import HTTPBasicAuth
$ auth = HTTPBasicAuth('fake@example.com', 'not_a_real_password')
$ r = requests.post(url=url, data=body, auth=auth)
$ r.status_code
201
$ content = r.json()
$ print(content[u'body'])
Sounds great! I'll get right on it.
</code></pre>
</div>

<p>精彩！噢，不！我原本是想说等我一会，因为我得去喂一下我的猫。如果我能够编辑这条评论那就好了！ 幸运的是，GitHub 允许我们使用另一个 HTTP 动词，PATCH，来编辑评论。我们来试试。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ print(content[u"id"])
5804413
$ body = json.dumps({u"body": u"Sounds great! I'll get right on it once I feed my cat."})
$ url = u"https://api.github.com/repos/kennethreitz/requests/issues/comments/5804413"
$ r = requests.patch(url=url, data=body, auth=auth)
$ r.status_code
200
</code></pre>
</div>

<p>非常好。现在，我们来折磨一下这个叫肯尼思的家伙，我决定要让他急得团团转，也不告诉他是我在捣蛋。 这意味着我想删除这条评论。GitHub 允许我们使用完全名副其实的 DELETE 方法来删除评论。我们来清除该评论。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ r = requests.delete(url=url, auth=auth)
$ r.status_code
204
$ r.headers['status']
'204 No Content'
</code></pre>
</div>

<p>很好。不见了。最后一件我想知道的事情是我已经使用了多少限额（ratelimit）。查查看，GitHub 在响应头部发送这个信息， 因此不必下载整个网页，我将使用一个 HEAD 请求来获取响应头。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ r = requests.head(url=url, auth=auth)
$ print r.headers
...
'x-ratelimit-remaining': '4995'
'x-ratelimit-limit': '5000'
...
</code></pre>
</div>

<p>很好。是时候写个 Python 程序以各种刺激的方式滥用 GitHub 的 API，还可以使用4995次呢。</p>

<hr />

<h3 id="headlink"><a href="#headlink">响应头链接字段</a></h3>

<p>许多 HTTP API 都有响应头链接字段的特性，它们使得 API 能够更好地自我描述和自我显露。</p>

<p>GitHub 在 API 中为分页 使用这些特性，例如:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ url = 'https://api.github.com/users/kennethreitz/repos?page=1&amp;per_page=10'
$ r = requests.head(url=url)
$ r.headers['link']
'&lt;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&gt;; rel="next", &lt;https://api.github.com/users/kennethreitz/repos?page=6&amp;per_page=10&gt;; rel="last"'
</code></pre>
</div>

<p>Requests 会自动解析这些响应头链接字段，并使得它们非常易于使用:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ r.links["next"]
{'url': 'https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10', 'rel': 'next'}

$ r.links["last"]
{'url': 'https://api.github.com/users/kennethreitz/repos?page=7&amp;per_page=10', 'rel': 'last'}
</code></pre>
</div>

<hr />

<h3 id="transport-adapterstransportada"><a href="#transportada">Transport Adapters</a></h3>

<p>As of v1.0.0, Requests has moved to a modular internal design. Part of the reason this was done was to implement Transport Adapters, originally <a href="http://www.kennethreitz.org/essays/the-future-of-python-http">described here</a>. Transport Adapters provide a mechanism to define interaction methods for an HTTP service. In particular, they allow you to apply per-service configuration.</p>

<p>Requests ships with a single Transport Adapter, the HTTPAdapter. This adapter provides the default Requests interaction with HTTP and HTTPS using the powerful urllib3 library. Whenever a Requests Session is initialized, one of these is attached to the Session object for HTTP, and one for HTTPS.</p>

<p>Requests enables users to create and use their own Transport Adapters that provide specific functionality. Once created, a Transport Adapter can be mounted to a Session object, along with an indication of which web services it should apply to.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ s = requests.Session()
$ s.mount('http://www.github.com', MyAdapter())
</code></pre>
</div>

<p>The mount call registers a specific instance of a Transport Adapter to a prefix. Once mounted, any HTTP request made using that session whose URL starts with the given prefix will use the given Transport Adapter.</p>

<p>Many of the details of implementing a Transport Adapter are beyond the scope of this documentation, but take a look at the next example for a simple SSL use- case. For more than that, you might look at subclassing <code class="highlighter-rouge">requests.adapters.BaseAdapter</code>.</p>

<hr />

<h3 id="example-specific-ssl-versionexample"><a href="#example">Example: Specific SSL Version</a></h3>

<p>The Requests team has made a specific choice to use whatever SSL version is default in the underlying library (<a href="https://github.com/shazow/urllib3">urllib3</a>). Normally this is fine, but from time to time, you might find yourself needing to connect to a service-endpoint that uses a version that isn’t compatible with the default.</p>

<p>You can use Transport Adapters for this by taking most of the existing implementation of HTTPAdapter, and adding a parameter <code class="highlighter-rouge">ssl_version</code> that gets passed-through to urllib3. We’ll make a TA that instructs the library to use SSLv3:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import ssl

from requests.adapters import HTTPAdapter
from requests.packages.urllib3.poolmanager import PoolManager


class Ssl3HttpAdapter(HTTPAdapter):
    """"Transport adapter" that allows us to use SSLv3."""

    def init_poolmanager(self, connections, maxsize, block=False):
        self.poolmanager = PoolManager(num_pools=connections,
                                       maxsize=maxsize,
                                       block=block,
                                       ssl_version=ssl.PROTOCOL_SSLv3)
</code></pre>
</div>

<hr />

<h3 id="blocking-or-non-blockingblocking"><a href="#blocking">Blocking Or Non-Blocking?</a></h3>

<p>With the default Transport Adapter in place, Requests does not provide any kind of non-blocking IO. The <a href="http://cn.python-requests.org/en/latest/api.html#requests.Response.content">Response.content</a> property will block until the entire response has been downloaded. If you require more granularity, the streaming features of the library (see <a href="http://cn.python-requests.org/en/latest/user/advanced.html#streaming-requests">流式请求</a>) allow you to retrieve smaller quantities of the response at a time. However, these calls will still block.</p>

<p>If you are concerned about the use of blocking IO, there are lots of projects out there that combine Requests with one of Python’s asynchronicity frameworks. Two excellent examples are <a href="https://github.com/kennethreitz/grequests">grequests</a> and <a href="https://github.com/ross/requests-futures">requests-futures</a>.</p>

<hr />

<h3 id="timeoutstimeout"><a href="#timeout">Timeouts</a></h3>

<p>Most requests to external servers should have a timeout attached, in case the server is not responding in a timely manner. Without a timeout, your code may hang for minutes or more.</p>

<p>The connect timeout is the number of seconds Requests will wait for your client to establish a connection to a remote machine (corresponding to the <a href="http://linux.die.net/man/2/connect">connect()</a>) call on the socket. It’s a good practice to set connect timeouts to slightly larger than a multiple of 3, which is the default <a href="http://www.hjp.at/doc/rfc/rfc2988.txt">TCP packet retransmission window</a>.</p>

<p>Once your client has connected to the server and sent the HTTP request, the read timeout is the number of seconds the client will wait for the server to send a response. (Specifically, it’s the number of seconds that the client will wait between bytes sent from the server. In 99.9% of cases, this is the time before the server sends the first byte).</p>

<p>If you specify a single value for the timeout, like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>r = requests.get('https://github.com', timeout=5)
</code></pre>
</div>

<p>The timeout value will be applied to both the connect and the read timeouts. Specify a tuple if you would like to set the values separately:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>r = requests.get('https://github.com', timeout=(3.05, 27))
</code></pre>
</div>

<p>If the remote server is very slow, you can tell Requests to wait forever for a response, by passing None as a timeout value and then retrieving a cup of coffee.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>r = requests.get('https://github.com', timeout=None)
</code></pre>
</div>

<hr />

<h3 id="ca-certificatescertificates"><a href="#certificates">CA Certificates</a></h3>

<p>By default Requests bundles a set of root CAs that it trusts, sourced from the <a href="https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt">Mozilla trust store</a>. However, these are only updated once for each Requests version. This means that if you pin a Requests version your certificates can become extremely out of date.</p>

<p>From Requests version 2.4.0 onwards, Requests will attempt to use certificates from <a href="http://certifi.io/">certifi</a> if it is present on the system. This allows for users to update their trusted certificates without having to change the code that runs on their system.</p>

<p>For the sake of security we recommend upgrading certifi frequently!</p>

<hr />

<h3 id="end">END</h3>



                <hr>

                


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/01/08/requests-summary/" data-toggle="tooltip" data-placement="top" title="Requests快速入门">
                        Previous<br>
                        <span>Requests快速入门</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2016/01/09/proxy-setup/" data-toggle="tooltip" data-placement="top" title="代理服务器的搭建方法">
                        Next<br>
                        <span>代理服务器的搭建方法</span>
                        </a>
                    </li>
                    
                </ul>


                

                

            </div>

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#杂谈" title="杂谈" rel="4">
                                    杂谈
                                </a>
                            
        				
                            
                				<a href="/tags/#Python" title="Python" rel="17">
                                    Python
                                </a>
                            
        				
                            
                				<a href="/tags/#Ubuntu" title="Ubuntu" rel="3">
                                    Ubuntu
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Flask" title="Flask" rel="3">
                                    Flask
                                </a>
                            
        				
                            
                				<a href="/tags/#Redis" title="Redis" rel="3">
                                    Redis
                                </a>
                            
        				
                            
                				<a href="/tags/#数据库" title="数据库" rel="2">
                                    数据库
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#Supervisor" title="Supervisor" rel="2">
                                    Supervisor
                                </a>
                            
        				
                            
                				<a href="/tags/#服务器" title="服务器" rel="6">
                                    服务器
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Lua" title="Lua" rel="2">
                                    Lua
                                </a>
                            
        				
                            
                				<a href="/tags/#Requests" title="Requests" rel="2">
                                    Requests
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Django" title="Django" rel="2">
                                    Django
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#AWK" title="AWK" rel="2">
                                    AWK
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#HBase" title="HBase" rel="2">
                                    HBase
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Thrift" title="Thrift" rel="2">
                                    Thrift
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Spider" title="Spider" rel="4">
                                    Spider
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Selenium" title="Selenium" rel="2">
                                    Selenium
                                </a>
                            
        				
                            
                				<a href="/tags/#PhantomJS" title="PhantomJS" rel="2">
                                    PhantomJS
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://pmars.cnblogs.com">pmars的博客</a></li>
                    
                        <li><a href="http://weibo.com/topmars">pmars的微博</a></li>
                    
                        <li><a href="http://github.com/pmars">我的项目</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>


<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/xiaoh">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/topmars">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/pmars">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Xiaoh's Blog 2018
                    <br>
                    Theme © <a href="http://xiaoh.me">Xiaoh</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=pmars&repo=pmars.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
    <div class="actGotop" style="">
        <div class="plane"></div>
        <div class="back-info">返回顶部</div>
    </div>
    <script>
        (function() {
            $(window).scroll(function(){
                if($(window).scrollTop()>500){
                    $('.actGotop').fadeIn();
                }else{
                    $('.actGotop').fadeOut();
                }
            }) 
            $('.actGotop').click(function(){
                $(window).scrollTop(0);
            });
        })();
    </script>
</footer>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- Highlight.js -->
<script>
    async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
        hljs.initHighlightingOnLoad();
    })
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>
<link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        // var $nav = document.querySelector("nav");
        // if($nav) FastClick.attach($nav);

        // global FastClick!!
        FastClick.attach(document.body);    
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-73800419-1';
    var _gaDomain = 'www.xiaoh.me';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'eb09bda7042f7733bd1bcba14d69d750';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
